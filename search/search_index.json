{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Immac' 2025 - 26","text":""},{"location":"bts/10_gammes/","title":"Les gammes","text":"<p>Voici quelques mini-exercices pour s'entra\u00eener aux basiques de la programmation en C/C++.</p>"},{"location":"bts/10_gammes/#variables","title":"Variables","text":"D\u00e9clarer et afficher une variable permettant de stocker le r\u00e9sultat de <code>42 * 42</code> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    short milleSeptCentSoixanteQuatre = 42 * 42;\n\n    printf(\"%hd\", milleSeptCentSoixanteQuatre);\n\n    return 0;\n}\n</code></pre> D\u00e9clarer et afficher une variable permettant de stocker le r\u00e9sultat de <code>42 * 10000.0</code> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    float quarante_deux_milliemes = 42 / 10000.0;\n\n    printf(\"%.f\", quarante_deux_milliemes);\n\n    return 0;\n}\n</code></pre> D\u00e9clarer et afficher une variable permettant de stocker le r\u00e9sultat de <code>42 / 10000000.0</code> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    float quarante_deux_dix_millioniemes = 42 / 10000000.0;\n\n    printf(\"%.7f\", quarante_deux_dix_millioniemes);\n\n    return 0;\n}\n</code></pre> D\u00e9clarer et afficher une variable permettant de stocker le PIB de la Roumanie . <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    long long pib_roumanie = 286509000000;\n\n    printf(\"%lld\", pib_roumanie);\n\n    return 0;\n}\n</code></pre> D\u00e9clarer et afficher une variable permettant de stocker le PIB des \u00eeles Tuvalu . <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    int pib_tuvalu = 47270000;\n\n    printf(\"%d\", pib_tuvalu);\n\n    return 0;\n}\n</code></pre> D\u00e9clarer et afficher une variable permettant de stocker le r\u00e9sultat de <code>sqrt(pow(42, 2) + pow(15, 3))</code>. <pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main() {\n\n    float hypotenuse = sqrt(pow(42, 2) + pow(15, 3));\n\n    printf(\"%f\", hypotenuse);\n\n    return 0;\n}\n</code></pre> D\u00e9clarer et afficher une variable permettant de stocker le r\u00e9sultat de <code>toupper('a')</code>. <pre><code>#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n\nint main() {\n\n    char a = toupper('a');\n\n    printf(\"%c\", a);\n\n    return 0;\n}\n</code></pre> Ecrire un programme qui demande la saisie d'un entier et l'affiche. <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    int entier;\n\n    scanf(\"%d\", &amp;entier);\n\n    printf(\"%d\", entier);\n\n    return 0;\n}\n</code></pre> Ecrire un programme qui demande la saisie d'un caract\u00e8re et affiche sa valeur num\u00e9rique dans la table ASCII en d\u00e9cimal et en h\u00e9xad\u00e9cimal. <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    char caractere;\n\n    scanf(\"%c\", &amp;caractere);\n\n    printf(\"%hhd, %x\", caractere, caractere);\n\n    return 0;\n}\n</code></pre>"},{"location":"bts/10_gammes/#conditions","title":"Conditions","text":"Ecrire un programme qui demande l'\u00e2ge de l'utilisateur puis indique s'il est majeur ou non. <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    int age;\n\n    printf(\"Quel est votre age ?\\n\");\n\n    scanf(\"%d\", &amp;age);\n\n    if (age &gt;= 18) {\n        printf(\"Vous etes majeur.\");\n    }\n    else {\n        printf(\"Vous n'etes pas majeur.\");\n    }\n\n    return 0;\n}\n</code></pre> Ecrire un programme qui demande un entier \u00e0 l'utilisateur puis lui indique s'il est pair, si c'est un multiple de 3 ou les deux. <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    int entier;\n\n    printf(\"Saisir un entier : \");\n\n    scanf(\"%d\", &amp;entier);\n\n    if (entier % 2 == 0 &amp;&amp; entier % 3 == 0) {\n        printf(\"%d est pair et multiple de 3.\", entier);\n    }\n    else if (entier % 2 == 0) {\n        printf(\"%d est pair.\", entier);\n    }\n    else if (entier % 3 == 0) {\n        printf(\"%d est multiple de 3.\", entier);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"bts/10_gammes/#boucles","title":"Boucles","text":"Ecrire un programme qui affiche les nombres de 1 \u00e0 100 inclus (avec un for et un while). <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    for (int i = 1; i &lt;= 100; i++) {\n        printf(\"%d \", i);\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    int i = 1;\n    while (i &lt;= 100) {\n        printf(\"%d \", i);\n        i++;\n    }\n\n    return 0;\n}\n</code></pre> Ecrire un programme qui affiche les nombres de 0 \u00e0 99 inclus (avec un for et un while). <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    for (int i = 0; i &lt;= 99; i++) {\n        printf(\"%d \", i);\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    int i = 0;\n    while (i &lt;= 99) {\n        printf(\"%d \", i);\n        i++;\n    }\n\n    return 0;\n}\n</code></pre> Ecrire un programme qui affiche les nombres impairs entre de 35 \u00e0 54 inclus (avec un for et un while). <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    for (int i = 35; i &lt;= 54; i += 2) {\n        printf(\"%d \", i);\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    int i = 35;\n    while (i &lt;= 54) {\n        printf(\"%d \", i);\n        i += 2;\n    }\n\n    return 0;\n}\n</code></pre> Ecrire un programme qui affiche un d\u00e9compte de 59 \u00e0 0 (avec un for et un while). <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    for (int i = 59; i &gt;= 0; i--) {\n        printf(\"%d \", i);\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    int i = 59;\n    while (i &gt;= 0) {\n        printf(\"%d \", i);\n        i--;\n    }\n\n    return 0;\n}\n</code></pre> Ecrire un programme qui calcule le factoriel d'un nombre saisi par l'utilisateur (maximum 20!).Rappel : $ n! = n * n - 1 * ... * 2 * 1 $ et \\(0! = 1\\) <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    int nombre;\n    long long factoriel = 1;\n\n    printf(\"Saisir un nombre : \");\n    scanf(\"%d\", &amp;nombre);\n\n    if (nombre &gt; 20) {\n        printf(\"Desole, je ne peux pas caluler plus que 20!\");\n        return -1;\n    }\n\n    for(int i = nombre; i &gt; 1; i--) {\n        factoriel *= i;\n    }\n\n    printf(\"%d! = %lld\", nombre, factoriel);\n\n    return 0;\n}\n</code></pre> Ecrire un programme qui demande \u00e0 l'utilisateur de deviner un nombre choisi al\u00e9atoirement entre 1 et 10. Le nombre de tentatives est affich\u00e9 \u00e0 la fin. <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main() {\n\n    srand(time(NULL));\n\n    int entier = 0, entierATrouver = rand() % 10 + 1, tentatives = 0;        \n\n    printf(\"Devine un nombre entre 1 et 10 :\\n\");\n\n    while (entier != entierATrouver) {\n        tentatives++;\n        printf(\"Essai %d : \", tentatives);\n        scanf(\"%d\", &amp;entier);\n    }\n\n    printf(\"Bravo ! Tu as trouve %d en %d coup(s) !\", entierATrouver, tentatives);\n\n    return 0;\n}\n</code></pre> Ecrire un programme qui affiche un d\u00e9compte de 30 secondes. <pre><code>#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nint main() {\n\n    time_t current = time(NULL);\n    time_t previous = current, stop = current + 30;\n    int remaining = 30;\n\n    while ((current = time(NULL)) &lt;= stop) {\n        if (current - previous == 1) {\n            previous = current;\n            remaining--;\n            printf(\"%d\\n\", remaining);\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"bts/20_stages/","title":"Stages","text":""},{"location":"bts/20_stages/#livret-de-stage","title":"Livret de stage","text":"<p> T\u00e9l\u00e9charger le livret de stage</p>"},{"location":"bts/20_stages/#liste-des-competences","title":"Liste des comp\u00e9tences","text":"<p> T\u00e9l\u00e9charger la liste des comp\u00e9tences</p>"},{"location":"bts/20_stages/#attestation-de-stage","title":"Attestation de stage","text":"<p> T\u00e9l\u00e9charger l'attestation de stage</p>"},{"location":"bts/20_stages/#evaluation","title":"Evaluation","text":"<p> T\u00e9l\u00e9charger la fiche d'\u00e9valuation</p>"},{"location":"bts/20_stages/#carte-des-entreprises","title":"Carte des entreprises","text":"<p>Entreprises ayant accueilli ou \u00e9tant susceptibles d'accueillir des stagiaires BTS CIEL.</p>"},{"location":"bts/20_stages/#legende","title":"L\u00e9gende","text":"<ul> <li> <p>Industriels</p> </li> <li> <p>Prestataires de services (r\u00e9seaux et informatiques)</p> </li> <li> <p>Informatique de gestion</p> </li> <li> <p>Secteur public et associatif</p> </li> </ul>"},{"location":"bts/99_plusplus/","title":"Plus Plus","text":"<p>Que faire quand j'ai fini les exercices en avance ???</p> <p></p> <p>Voici quelques pistes :</p> <ul> <li> <p>Gonfler mon score PIX</p> </li> <li> <p>Pr\u00e9parer la Nuit du code </p> <ul> <li> <p>La documentation de pyxel</p> </li> <li> <p>Le tuto pour en programmation imp\u00e9rative</p> </li> <li> <p>Le tuto pour en programmation orient\u00e9e objet</p> </li> <li> <p>Les assets de l'ann\u00e9e derni\u00e8re</p> </li> </ul> </li> <li> <p>D\u00e9couvrir l'OSINT et s'entra\u00eener pour Passe ton hack d'abord_</p> </li> <li> <p>M'entra\u00eener \u00e0 la programmation avec les challenges Prologin</p> </li> </ul>"},{"location":"bts-1/00-waitforit/","title":"Wait for it...","text":""},{"location":"bts-1/10-projet-thelma/","title":"Projet Thelma","text":"<p>D\u00e9veloppons un programme pour aider une \u00e9coli\u00e8re de CE1 \u00e0 r\u00e9viser ses tables !</p>"},{"location":"bts-1/10-projet-thelma/#themes-abordes","title":"Th\u00e8mes abord\u00e9s","text":"<ul> <li>variables, </li> <li>conditions, </li> <li>boucles, </li> <li>I/O, </li> <li>fichiers, </li> <li>al\u00e9atoire, </li> <li>fonctions, </li> <li>chrono</li> </ul>"},{"location":"bts-1/10-projet-thelma/#avancement","title":"Avancement","text":"<p>Programme par d\u00e9faut en C :</p> <pre><code>#include &lt;stdio.h&gt;              // La biblioth\u00e8que qui permet d'utiliser printf.\n\nint main() {                    // La fonction principale, le point d'entr\u00e9e du programme.\n    printf(\"hello, world!\");    // Affiche \"hello, world!\" dans la sortie standard.\n    return 0;                   // R.A.S., on signale \u00e0 l'OS que tout s'est bien pass\u00e9.\n}\n</code></pre> <ol> <li> <p>Afficher un calcul et son r\u00e9sultat</p> <ol> <li> <p>En \u201cdur\u201d</p> <pre><code>printf(\"1 + 1 = 2\");  \nprintf(\"1 + 1 = 42\");  \n</code></pre> </li> <li> <p>En calculant vraiment</p> <pre><code>printf(\"%d + %d = %d\\n\", 1, 1, 1 + 1);\n</code></pre> </li> </ol> </li> <li> <p>Afficher une table d'addition</p> <ol> <li> <p>Avec 10 printf</p> <pre><code>printf(\"%d + %d = %d\\n\", 1, 0, 1 + 0);\nprintf(\"%d + %d = %d\\n\", 1, 1, 1 + 1);\nprintf(\"%d + %d = %d\\n\", 1, 2, 1 + 2);\nprintf(\"%d + %d = %d\\n\", 1, 3, 1 + 3);\nprintf(\"%d + %d = %d\\n\", 1, 4, 1 + 4);\nprintf(\"%d + %d = %d\\n\", 1, 5, 1 + 5);\nprintf(\"%d + %d = %d\\n\", 1, 6, 1 + 6);\nprintf(\"%d + %d = %d\\n\", 1, 7, 1 + 7);\nprintf(\"%d + %d = %d\\n\", 1, 8, 1 + 8);\nprintf(\"%d + %d = %d\\n\", 1, 9, 1 + 9);\n</code></pre> </li> <li> <p>Avec une boucle</p> <pre><code>// Avec une boucle while (tant que) qui r\u00e9p\u00e8te les instructions qu'elle contient tant que la condition est vraie.\nint n2 = 0; // Utilisation d'une variable pour stocker la valeur \u00e0 ajouter qui s'incr\u00e9mente \u00e0 chaque it\u00e9ration de la boucle.\nwhile (n2 &lt; 10) {\n    printf(\"1 + %d = %2d\\n\", n2, 1 + n2);\n    n2 = n2 + 1; // On incr\u00e9mente n2 sinon on a une boucle infinie.\n}\n\n// Avec une boucle for (pour)\nfor (n2 = 0; n2 &lt; 10; n2 = n2 + 1) {\n    printf(\"1 + %d = %2d\\n\", n2, 1 + n2);\n}\n</code></pre> </li> <li> <p>En laissant le choix \u00e0 l'utilisateur</p> <pre><code>int n1, n2 = 0;\n\n// Choix de la table\ndo {\n    printf(\"Quelle table [0-9] souhaitez-vous afficher ?\\n\");\n    scanf(\"%d\", &amp;n1);\n} while (n1 &lt; 0 || n1 &gt; 9);\n\nwhile (n2 &lt; 10) {\n    printf(\"%d + %d = %2d\\n\", n1, n2, n1 + n2);\n    n2 = n2 + 1;\n}\n</code></pre> </li> </ol> </li> <li> <p>Afficher toutes les tables</p> <ol> <li> <p>Pour un op\u00e9rateur en \"dur\"</p> <pre><code>int n1 = 1, n2 = 0;\n\n// Boucles imbriqu\u00e9es\n// La premi\u00e8re permet de passer de table en table\nwhile (n1 &lt; 10) {\n    printf(\"Table de %d\\n----------\\n\", n1);\n\n    // La seconde (d\u00e9j\u00e0 vue) affiche chaque table\n    while (n2 &lt; 10) {\n        printf(\"%d + %d = %2d\\n\", n1, n2, n1 + n2);\n        n2 = n2 + 1;\n    }\n\n    n1 = n1 + 1;\n    n2 = 0;\n    printf(\"\\n\");\n}\n</code></pre> </li> <li> <p>Pour un op\u00e9rateur au choix </p> <pre><code>#include &lt;stdio.h&gt;\n\nint main () {\n\n    int signe, n1, n2 = 0;\n\n    // Choix du signe\n    do {\n        printf(\"De quelle op\u00e9ration affiche-t-on la table ?\\n1. Addition\\n2. Soustraction\\n3. Multiplication\\n&gt; \");\n        scanf(\"%d\", &amp;signe);\n    } while (signe != 1 &amp;&amp; signe != 2 &amp;&amp; signe != 3);\n\n    // Choix de la table\n    do {\n        printf(\"Quelle table [0-9] souhaitez-vous afficher ?\\n\");\n        scanf(\"%d\", &amp;n1);\n    } while (n1 &lt; 0 || n1 &gt; 9);\n\n    while (n2 &lt; 10) {\n        // Addition\n        if (signe == 1) {\n            printf(\"%d + %d = %2d\\n\", n1, n2, n1 + n2);\n        }\n        // Soustraction\n        else if (signe == 2) {\n            printf(\"%d - %d = %2d\\n\", n1, n2, n1 - n2);\n            if (n1 - n2 == 0) {\n                break;\n            }\n        }\n        // Multiplication\n        else if (signe == 3) {\n            printf(\"%d x %d = %2d\\n\", n1, n2, n1 * n2);\n        }\n        n2 = n2 + 1;\n    }\n\n    return 0;\n}\n</code></pre> </li> </ol> </li> <li> <p>Poser une question \u00e0 l\u2019utilisateur</p> <ul> <li> <p> G\u00e9n\u00e9rer des nombres al\u00e9atoirement : <code>srand()</code> et <code>rand()</code></p> Exemple <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt; // Biblioth\u00e8que contenant srand() et rand()\n#include &lt;time.h&gt;   // Biblioth\u00e8que contenant time()\n\nint main() {\n\n    /* \n    1 - Initialisation du seed pour l'al\u00e9atoire\n    On l'initialise avec time(NULL) qui renvoie l'heure du \n    syst\u00e8me en seconde de mani\u00e8re \u00e0 avoir une valeur diff\u00e9rente \n    \u00e0 chaque ex\u00e9cution.\n    On ne le fait qu'une seule fois au d\u00e9but du programme.\n    */\n\n    srand(time(NULL));\n\n    /*\n    2 - G\u00e9n\u00e9ration d'un nombre al\u00e9atoire\n    On r\u00e9cup\u00e8re le reste de la division du r\u00e9sultat de rand() \n    par 10 (modulo 10 ou % 10) pour r\u00e9cup\u00e9rer un nombre entre 0 et 9.\n    */\n\n    int a = rand() % 10, b = rand() % 10;\n\n    printf(\"%d + %d = ?\\n\", a, b);\n\n    return 0;\n}\n</code></pre> </li> <li> <p> Demander une saisie \u00e0 l'utilisateur : <code>scanf()</code></p> </li> <li> <p> Afficher des valeurs diff\u00e9rentes \u00e0 chaque calcul : <code>printf()</code> et variables</p> </li> <li> <p> V\u00e9rifie le r\u00e9sultat : <code>if</code> ou <code>while</code> </p> </li> <li> <p> Poser 10 questions : <code>for</code></p> </li> <li> <p> Demander \u00e0 l'utilisateur d'appuyer sur une touche (n'importe laquelle...) : <code>getchar()</code></p> </li> </ul> <p>Exemple : <pre><code>3 x 5 = ?\n&gt; 10\nOups ! La bonne r\u00e9ponse est 15.\n\nAppuie sur une touche pour continuer...\n</code></pre></p> <pre><code>2 + 5 = ?\n&gt; 7\nBravo !\n\nAppuie sur une touche pour continuer...\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main() {\n\n    // Initialiser le seed pour l'al\u00e9atoire\n    srand(time(NULL));\n\n    int a, b, input, result;\n\n    for (int i = 1; i &lt;= 10; i++) {\n\n        // Afficher le calcul \u00e0 effectuer\n        b = rand() % 10;\n        a = rand() % 10;\n        result = a + b;\n\n        system(\"cls\");\n        printf(\"Question %d :\\n\\n\", i);\n\n        printf(\"%d + %d = ?\\n&gt; \", a, b);\n\n        // G\u00e9rer la r\u00e9ponse de l'utilisateur\n        scanf(\"%d\", &amp;input);\n\n        // Valider la r\u00e9ponse\n        if (input == result) {\n            printf(\"Bravo !\");\n        }\n        else {\n            printf(\"Oups ! La bonne r\u00e9ponse est %d.\", result);\n        }\n\n        // Attendre...\n        printf(\"\\n\\nAppuyer sur Entr\u00e9e pour continuer...\");\n        getchar();\n        getchar();\n    }\n\n    return 0;\n}\n</code></pre> </li> <li> <p>Cr\u00e9er un menu</p> <p></p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;conio.h&gt;\n\nint menu() {\n    int choice = 1;\n    int keyPressed = 0;\n    while (keyPressed != 13) {\n\n        system(\"cls\");\n        printf(\"%c Option 1\\n%c Option 2\\n%c Option 3\\n\", \n            choice == 1 ? '&gt;' : ' ', \n            choice == 2 ? '&gt;' : ' ', \n            choice == 3 ? '&gt;' : ' '\n        );\n\n        //while (!kbhit()) {}\n\n        keyPressed = getch();\n        if (keyPressed == 72) {\n            choice--;\n            if (choice &lt; 1) {\n                choice = 3;\n            }\n        }\n        if (keyPressed == 80) {\n            choice++;\n            if (choice &gt; 3) {\n                choice = 1;\n            }\n        }\n    }\n    return choice;\n}\n\nint main() {\n    system(\"chcp 65001\");\n    system(\"cls\");\n    printf(\"%d\", menu());\n}\n</code></pre> </li> <li> <p>Cr\u00e9er un premier programme complet :</p> <pre><code>#include &lt;stdio.h&gt;\n\nvoid menu_principal();\nvoid menu_quizz();\nvoid afficher_table();\nvoid afficher_tables();\nvoid parametrer_quizz_chrono();\nvoid lancer_quizz_chrono(char operateur, int table);\nvoid parametrer_quizz_compte();\nvoid lancer_quizz_compte(char operateur, int table, int nb_question);\n\nint main() {\n    menu_principal();\n    return 0;\n}\n\n/**\n* @brief Affiche le menu principal\n* \n*/\nvoid menu_principal() {\n\n}\n\n/**\n* @brief Affiche le menu de choix parmi les quizz\n* \n*/\nvoid menu_quizz() {\n\n}\n\n/**\n* @brief Demande \u00e0 l'utilisateur un op\u00e9rateur (+, -, x) et un chiffre (0-9) et lui affiche la table de ce chiffre\n* \n*/\nvoid afficher_table() {\n\n}\n\n/**\n* @brief Demande \u00e0 l'utilisateur un op\u00e9rateur (+, -, x) et affiche sous la forme d'un tableau les tables pour tous les chiffres (0-9)\n* \n*/\nvoid afficher_tables() {\n\n}\n\n/**\n* @brief Demande \u00e0 l'utilisateur un op\u00e9rateur (+, -, x) et un chiffre (0-9) et lance un quiz chrono avec ces param\u00e8tres\n* \n*/\nvoid parametrer_quizz_chrono() {\n\n}\n\n/**\n* @brief G\u00e9n\u00e8re 20 calculs \u00e0 trous (op\u00e9rande ou r\u00e9sultat) pour la table et l'op\u00e9rateur demand\u00e9 en bloquant tant que la r\u00e9ponse n'est pas bonne.\n*        Le score correspond au temps pass\u00e9 \u00e0 r\u00e9pondre aux 20 questions correctement.\n* \n* @param operateur (char) L'op\u00e9rateur \u00e0 utiliser dans le quizz\n* @param table     (int)  La table \u00e0 utiliser dans le quizz\n*/\nvoid lancer_quizz_chrono(char operateur, int table) {\n\n}\n\n\n/**\n* @brief Demande \u00e0 l'utilisateur un op\u00e9rateur (+, -, x), un chiffre (0-9) et un nombre de questions et lance un quiz compt\u00e9 avec ces param\u00e8tres\n* \n*/\nvoid parametrer_quizz_compte() {\n\n}\n\n/**\n* @brief G\u00e9n\u00e8re nb_questions calculs \u00e0 trous (op\u00e9rande ou r\u00e9sultat) pour la table et l'op\u00e9rateur demand\u00e9 en affichant la r\u00e9ponse apr\u00e8s le calcul.\n*        Le score est le nombre de bonnes r\u00e9ponses.\n* \n* @param operateur     (char) L'op\u00e9rateur \u00e0 utiliser dans le quizz\n* @param table         (int)  La table \u00e0 utiliser dans le quizz\n* @param nb_questions  (int)  Le nombre de questions \u00e0 poser\n*/\nvoid lancer_quizz_compte(char operateur, int table, int nb_questions) {\n\n}\n\n// Evolution : se souvenir des calculs et afficher les r\u00e9ponses \u00e0 la fin\n</code></pre> </li> <li> <p>Cr\u00e9er un quiz chronom\u00e9tr\u00e9</p> <pre><code>\n</code></pre> </li> <li> <p>Cr\u00e9er un quiz minut\u00e9 ?</p> <pre><code>\n</code></pre> </li> <li> <p>Cr\u00e9er un quiz qui donne les r\u00e9ponses juste apr\u00e8s chaque question ou \u00e0 la fin de toutes les questions </p> <pre><code>\n</code></pre> </li> <li> <p>Cr\u00e9er un top</p> <ol> <li>En m\u00e9moire</li> </ol> <pre><code>\n</code></pre> <ol> <li>Sauvegard\u00e9</li> </ol> <pre><code>\n</code></pre> </li> <li> <p>Tester</p> </li> <li> <p>Livrer</p> </li> </ol>"},{"location":"bts-1/20-premiers-programmes/","title":"01 - Premiers programmes","text":""},{"location":"bts-1/20-premiers-programmes/#recapitulatif","title":"R\u00e9capitulatif","text":"<pre><code>%%{init: {'theme':'base'}}%%\nmindmap\n  root((Langage C))\n    Compilateur\n        langage compil\u00e9 != langage interpr\u00e9t\u00e9 (Python, PHP)\n        4 \u00e9tapes\n            1 - Pr\u00e9-processeur\n                Suppression des commentaires\n                R\u00e9cup\u00e9ration du contenu des biblioth\u00e8ques\n            2 - Compilateur\n                Traduction en assembleur\n            3 - Assemblage\n                Traduction en binaire\n            4 - Editeur de liens\n                R\u00e9cup\u00e9ration des biblioth\u00e8ques pr\u00e9-compil\u00e9es\n                Ajout des routines pour l'ex\u00e9cution\n    Variables\n        Types\n            Entiers\n                char 1 octet\n                int 4 octets\n            R\u00e9els\n                float\n        Identificateur\n    Fonctions\n        Principale main\n            Point d'entr\u00e9e du programme\n        Biblioth\u00e8ques \n            #include\n            stdio.h\n                [\"printf()\"]\n                [\"scanf()\"]\n    Op\u00e9rateurs\n        Arithm\u00e9tiques\n        Relationnels\n        Logiques\n        Adresse\n    Logique\n        if...else if...else\n    Boucles\n        Nombre de r\u00e9p\u00e9titions connu ?\n            for\n        En attendant un \u00e9v\u00e9nement ?\n            while\n            Au moins une r\u00e9p\u00e9tion n\u00e9cessaire ?\n                do...while</code></pre>"},{"location":"bts-1/20-premiers-programmes/#exercice-1","title":"Exercice 1","text":"<p>Cr\u00e9er un programme <code>exo1.c</code> qui demande \u00e0 l'utilisateur son ann\u00e9e de naissance et lui donne son \u00e2ge.</p> <pre><code>&gt; ./exo1.exe\nAnnee de naissance : 1984\nVous avez 38 ans !\n</code></pre> <p>On sera plus pr\u00e9cis dans l'exercice 3</p> Correction <pre><code>#include &lt;stdio.h&gt;\n#define ANNEE 2025\n\nint main() {\n    int annee_utilisateur;\n\n    printf(\"Annee de naissance : \");\n    scanf(\"%d\", &amp;annee_utilisateur);\n    printf(\"Vous avez %d ans !\", ANNEE - annee_utilisateur);\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/20-premiers-programmes/#exercice-2","title":"Exercice 2","text":"<p>Cr\u00e9er un programme <code>exo2.c</code> qui demande \u00e0 l'utilisateur sa date de naissance et lui souhaite un joyeux anniversaire si c'est aujourd'hui.</p> <p>R\u00e9fl\u00e9chir sur le papier</p> <p>La date du jour doit \u00eatre d\u00e9finie dans des constantes.</p> <pre><code>// Si nous sommes le 22/09 \ud83d\ude04\n\n&gt; ./exo2.exe\nDate de naissance : 22/09/1984\nJoyeux anniversaire !\n\n&gt; ./exo2.exe\nDate de naissance : 07/09/1984\nJoyeux non-anniversaire !\n</code></pre> Correction <pre><code>#include &lt;stdio.h&gt;\n\n#define MOIS    9\n#define JOUR    22\n\nint main() {\n    int annee_utilisateur, mois_utilisateur, jour_utilisateur;\n\n    printf(\"Date de naissance : \");\n    scanf(\"%d/%d/%d\", &amp;jour_utilisateur, &amp;mois_utilisateur, &amp;annee_utilisateur);\n\n    if (mois_utilisateur == MOIS &amp;&amp; jour_utilisateur == JOUR) {\n        printf(\"Joyeux anniversaire !\");\n    }\n    else {\n        printf(\"Joyeux non-anniversaire !\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/20-premiers-programmes/#exercice-3","title":"Exercice 3","text":"<p>Cr\u00e9er un programme exo3.c qui demande \u00e0 l'utilisateur son ann\u00e9e, puis son mois, puis son jour de naissance et lui donne son \u00e2ge plus pr\u00e9cis\u00e9ment qu'\u00e0 l'exercice 1.</p> <pre><code>// Si nous sommes le 22/09 \ud83d\ude04\n\n&gt; ./exo3.exe\nDate de naissance : 25/09/1984\nVous avez 40 ans !\n\n&gt; ./exo3.exe\nDate de naissance : 20/09/1984\nVous avez 41 ans !\n</code></pre> Correction <pre><code>#include &lt;stdio.h&gt;\n\n#define MOIS    9\n#define JOUR    22\n#define ANNEE    2025\n\nint main() {\n    int annee_utilisateur, mois_utilisateur, jour_utilisateur, age;\n\n    printf(\"Date de naissance : \");\n    scanf(\"%d/%d/%d\", &amp;jour_utilisateur, &amp;mois_utilisateur, &amp;annee_utilisateur);\n\n    age = ANNEE - annee_utilisateur - 1;\n\n    if (mois_utilisateur &lt; MOIS || (mois_utilisateur == MOIS &amp;&amp; jour_utilisateur &lt;= JOUR)) {\n        age++;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/20-premiers-programmes/#exercice-sur-papier-1","title":"Exercice sur papier 1","text":"<p>Soit le programme suivant :</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 0, b = 1, c = 2, d = 3;\n\n    a = 5;                  // a:      b:     c:     d:\n    a + b;                  // a:      b:     c:     d:\n    c = a + b;              // a:      b:     c:     d:\n    d = a - (2 * d - b);    // a:      b:     c:     d: \n    c = a + b * -c + 1;     // a:      b:     c:     d:\n    a = b = c;              // a:      b:     c:     d:\n\n    return 0;\n}\n</code></pre> <p>D\u00e9finir sur papier les valeurs stock\u00e9es dans les variables a, b, c et d \u00e0 la fin de chaque instruction.</p> <p>Les priorit\u00e9 des calculs sont les m\u00eames qu'en math\u00e9matiques</p> Correction <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 0, b = 1, c = 2, d = 3;\n\n    a = 5;                  // a: 5    b: 1   c: 2   d: 3\n    a + b;                  // a: 5    b: 1   c: 2   d: 3\n    c = a + b;              // a: 5    b: 1   c: 6   d: 3\n    d = a - (2 * d - b);    // a: 5    b: 1   c: 6   d: 0\n    c = a + b * -c + 1;     // a: 5    b: 1   c: 0   d: 0\n    a = b = c;              // a: 0    b: 0   c: 0   d: 0\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/20-premiers-programmes/#exercice-sur-papier-2","title":"Exercice sur papier 2","text":"<p>Le programme suivant ne fonctionne pas... Pourquoi ?</p> <pre><code>#include &lt;stio.h&gt;\n\nmain() {\n    int jour = 0, mois = 0 annee = 0;\n\n    printf(\"Donner un jour (1-31) : );\n    scanf(\"%d\", &amp;jour);\n\n    printf(\"Donner un mois (1-12) : \");\n    scanf(\"%d\", mois);\n\n    printf(\"Donner un ann\u00e9e (0-2021) : \")\n    scanf(\"%d\", &amp;annee);\n\n    print(\"La date saisie est : %02d/%02d/%04d\", jour, mois, annee);\n\n    return 0;\n}\n</code></pre> Correction <pre><code>#include &lt;stdio.h&gt; // et non stio\n\nint main() { // et non main() tout court\n    int jour = 0, mois = 0, annee = 0; // Il manquait une virgule\n\n    printf(\"Donner un jour (1-31) : \"); // Chaine de caract\u00e8re \u00e0 fermer\n    scanf(\"%d\", &amp;jour);\n\n    printf(\"Donner un mois (1-12) : \");\n    scanf(\"%d\", &amp;mois); // Sans le &amp;, on risque l'erreur de segmentation\n\n    printf(\"Donner un ann\u00e9e (0-2021) : \"); // Avec un point-virgule\n    scanf(\"%d\", &amp;annee);\n\n    printf(\"La date saisie est : %02d/%02d/%04d\", jour, mois, annee); // et non print\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/20-premiers-programmes/#exercice-4","title":"Exercice 4","text":"<p>Cr\u00e9er un programme exo4.c qui demande un entier \u00e0 l'utilisateur puis lui affiche la conversion en hexad\u00e9cimal et en octal.</p> <pre><code>&gt; ./exo4.exe\nNombre \u00e0 convertir : 42\nHexad\u00e9cimal : 2A\nOctal : 52\n</code></pre> Un indice ? <p>Format pour <code>printf</code> :</p> <ul> <li> <p>Octal : <code>%o</code></p> </li> <li> <p>Hexad\u00e9cimal : <code>%X</code></p> </li> </ul> Correction <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int nombre;\n\n    printf(\"Nombre \u00e0 convertir : \");\n    scanf(\"%d\", &amp;nombre);\n\n    printf(\"Hexadecimal : %X\\n\", nombre);\n    printf(\"Octal : %o\", nombre);\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/20-premiers-programmes/#exercice-5","title":"Exercice 5","text":"<p>Cr\u00e9er un programme exo5.c qui convertit des composantes RGB de d\u00e9cimal en hexad\u00e9cimal.</p> <pre><code>&gt; ./exo5.exe\nCouleur en d\u00e9cimal : 255 204 0\nCouleur en hexa    : #FFCC00\n</code></pre> Aller plus loin <p>Programmer l'inverse.</p> <pre><code>&gt; ./exo5.exe\nCouleur en hexa    : #FFCC00\nCouleur en d\u00e9cimal : 255 204 0\n</code></pre> Correction <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    unsigned char r, g, b;\n\n    printf(\"Couleur en decimal : \");\n    scanf(\"%hhd %hhd %hhd\", &amp;r, &amp;g, &amp;b);\n\n    printf(\"Couleur en hexa    : #%02X%02X%02X\", r, g, b);\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/30-boucles/","title":"02 - Boucles","text":""},{"location":"bts-1/30-boucles/#exercice-1","title":"Exercice 1","text":"<p>Ecrire un programme qui affiche tous les nombres de 1 \u00e0 1000 avec les trois types de boucles.</p> Correction <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    int i;\n\n    // Boucle for\n    printf(\"for :\\n\");\n    for (i = 1; i &lt;= 1000; i++) {   // Faire attention aux bornes\n        printf(\"%d \", i);\n    }\n\n    // Boucle while\n    printf(\"\\n\\nwhile :\\n\");\n    i = 1;                          // Ne pas oublier d'initialiser le compteur avant la boucle\n    while (i &lt;= 1000) {\n        printf(\"%d \", i);\n        i++;\n    }\n\n    // Boucle do...while\n    printf(\"\\n\\ndo...while :\\n\");\n    i = 1;                          // idem\n    do {\n        printf(\"%d \", i);\n        i++;\n    } while (i &lt;= 1000);\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/30-boucles/#exercice-2","title":"Exercice 2","text":"<p>Ecrire un programme qui affiche les nombres pairs de 2 \u00e0 100 avec une boucle <code>for</code> de deux mani\u00e8res diff\u00e9rentes.</p> Correction <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    // M\u00e9thode 1 : on compte de 2 en 2\n    printf(\"Methode 1 :\\n\");\n    for (int i = 2; i &lt;= 100; i = i + 2) {\n        printf(\"%3d \", i);\n    }\n\n    // M\u00e9thode 2 : on compte de 1 en 1 mais on n'affiche que les nombres pairs\n    printf(\"\\n\\nMethode 2 :\\n\");\n    for (int i = 2; i &lt;= 100; i++) {\n        if (i % 2 == 0) {\n            printf(\"%3d \", i);\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/30-boucles/#exercice-3","title":"Exercice 3","text":"<p>Ecrire un programme qui demande un nombre positif \u00e0 l'utilisateur puis affiche le d\u00e9compte \u00e0 partir de ce nombre jusqu'\u00e0 0 avec les trois types de boucles.</p> Correction <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n\n    int start, i;\n\n    // Saisie\n    do {\n        printf(\"Saisir un nombre strictement positif : \");\n        scanf(\"%d\", &amp;start);\n    }\n    while (start &lt;= 0);\n\n    // D\u00e9compte avec un for\n    for (int i = start; i &gt;= 0; i--) {\n        printf(\"%d\\n\", i);\n    }\n\n    // D\u00e9compte avec un while\n    i = start;\n    while(i &gt;= 0) {\n        printf(\"%d\\n\", i);\n        i--;\n    }\n\n    // D\u00e9compte avec un do...while\n    i = start;\n    do {\n        printf(\"%d\\n\", i);\n        i--;\n    }\n    while(i &gt;= 0);\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/30-boucles/#exercice-en-attendant","title":"Exercice en attendant...","text":"<p>Ecrire un programme en C qui affiche les nombres de 1 \u00e0 100 (inclus) sauf : </p> <ul> <li> <p>si le nombre est un multiple de 3, il affiche \"fi\",</p> </li> <li> <p>si le nombre est un multiple de 5, il affiche \"foo\",</p> </li> <li> <p>si le nombre est un multiple de 3 et de 5, il affiche \"fifoo\".  </p> </li> </ul> <p>R\u00e9sultat :  <pre><code>&gt; ./exo4.exe\n1\n2\nfi\n4\nfoo\n5\nfi\n7\n8\nfi\n10\n11\nfi\n13\n14\nfifoo\n16\n...\n</code></pre></p>"},{"location":"bts-1/30-boucles/#exercice-4","title":"Exercice 4","text":"<p>Ecrire un programme pour g\u00e9rer la saisie du code \u00e0 4 chiffres d'une carte bancaire.</p> <p>L'utilisateur a 3 essais pour saisir correctement son code.</p> <p>Si le code est trouv\u00e9, afficher \"<code>Code bon</code>\".</p> <p>Si le code est faux, afficher \"<code>Code faux (X essai(s) restant(s))</code>\" o\u00f9 X est le nombre d'essais restants.</p> <p>Au sortir de la saisie, si le code est bon, afficher \"<code>Paiement en cours...</code>\", sinon afficher \"<code>Carte bloqu\u00e9e X(</code>\" </p> Correction <pre><code>#include &lt;stdio.h&gt;\n\n#define CODE_A_TROUVER 1234\n\nint main() {\n\n    int code_utilisateur = -1, tentatives = 0;\n\n    do {\n        printf(\"Votre code : \");\n        scanf(\"%d\", &amp;code_utilisateur);\n        tentatives++;\n        if (code_utilisateur == CODE_A_TROUVER) {\n            printf(\"Code bon\\n\");\n        }\n        else {\n            printf(\"Code faux (%d essai(s) restant(s))\\n\", 3 - tentatives);\n        }\n    } while (code_utilisateur != CODE_A_TROUVER &amp;&amp; tentatives &lt; 3);\n\n    if (code_utilisateur == CODE_A_TROUVER) {\n        printf(\"Paiement en cours...\");\n    }\n    else {\n        printf(\"Carte bloqu\u00e9e X(\");\n    }\n\n    return 0;\n}\n</code></pre> Aller plus loin <p>P\u00e9naliser les erreurs de saisie, en bloquant le programme pendant 5 puis 10 secondes en cas d'erreur.</p> Correction <pre><code>#include &lt;stdio.h&gt;\n\n#ifdef _WIN32\n#include &lt;windows.h&gt;\n#endif\n\n#ifdef linux\n#include &lt;unistd.h&gt;\n#endif\n\n#define CODE_A_TROUVER 1234\n\nint main() {\n\n    int code_utilisateur = -1, tentatives = 0, attente = 5;\n\n    do {\n        printf(\"Votre code : \");\n        scanf(\"%d\", &amp;code_utilisateur);\n        tentatives++;\n        if (code_utilisateur == CODE_A_TROUVER) {\n            printf(\"Code bon\\n\");\n        }\n        else {\n            printf(\"Code faux (%d essai(s) restant(s))\\n\", 3 - tentatives);\n\n            #ifdef _WIN32\n            Sleep(attente * 1000);\n            #endif\n\n            #ifdef linux\n            usleep(attente * 1000000);\n            #endif\n\n            attente += 5;\n        }\n    } while (code_utilisateur != CODE_A_TROUVER &amp;&amp; tentatives &lt; 3);\n\n    if (code_utilisateur == CODE_A_TROUVER) {\n        printf(\"Paiement en cours...\");\n    }\n    else {\n        printf(\"Carte bloqu\u00e9e X(\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/30-boucles/#exercice-5","title":"Exercice 5","text":"<p>Cr\u00e9er un programme <code>exo5.c</code> qui demande \u00e0 l\u2019utilisateur de deviner un nombre entre un 1 et 10 en maximum 3 essais.</p> <pre><code>&gt; ./exo5.exe\nDevine un nombre entre 1 et 10 (3 essais max.) !\nEssai 1 : 3\nPerdu !\nEssai 2 : 6\nPerdu !\nEssai 3 : 7\nPerdu ! C'\u00e9tait 8 !\n\n&gt; ./exo5.exe\nDevine un nombre entre 1 et 10 (3 essais max.) !\nEssai 1 : 4\nPerdu !\nEssai 2 : 6\nGagn\u00e9 !!!\n</code></pre> Correction <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main() {\n\n    // Graine pour les nombres al\u00e9atoires :\n    // A moins de lancer le programme deux fois dans la m\u00eame seconde, \n    // on aura un tirage diff\u00e9rent \u00e0 chaque fois... dans la limite du\n    // nombre de valeurs possibles \ud83d\ude43\n    srand(time(NULL));\n\n    // rand renvoie un nombre positif \"al\u00e9atoire\", il faut le ramener\n    // dans l'intervale souhait\u00e9. On sait qu'en r\u00e9cup\u00e9rent le reste \n    // de la division  par un nombre on r\u00e9cup\u00e8re une valeur entre 0 \n    // et ce nombre - 1. ex : 123456 % 10 va renvoyer un nombre entre\n    // 0 et 9. Si on ajoute 1 \u00e0 ce calcul, on obtient un nombre entre\n    // 1 et 10 \ud83d\ude0e\n    int nombreATrouver = rand() % 10 + 1, nombreSaisi, i = 1;\n\n    printf(\"Devine un nombre entre 1 et 10 (3 essais max.) !\");\n\n    // Il ne reste qu'\u00e0 boucler \ud83d\ude35\u200d\ud83d\udcab comme \u00e0 l'exercice pr\u00e9c\u00e9dent...\n    do {\n\n        printf(\"\\nEssai %d : \", i);\n        scanf(\"%d\", &amp;nombreSaisi);\n\n        if (nombreSaisi == nombreATrouver) {\n            printf(\"Gagne !!!\\n\");\n        }\n\n        printf(\"Perdu !\");\n        i++;\n    } while (i &lt;= 3 &amp;&amp; nombreSaisi != nombreATrouver);\n\n    if (i &gt; 3) {\n        printf(\" C'etait %d !\\n\", nombreATrouver);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/30-boucles/#exercice-6","title":"Exercice 6","text":"<p>Reprendre l\u2019exercice 5 en rendant les bornes (1 - 10) et le nombre de tentatives param\u00e9trables via des constantes.</p> <pre><code>&gt; ./exo6.exe\nDevine un nombre entre 1 et 99 (1 essai max.) !\nEssai 1 : 3\nPerdu ! C'\u00e9tait 83 !\n\n&gt; ./exo6.exe\nDevine un nombre entre 34 et 77 (24 essais max.) !\nEssai 1 : 44\nPerdu !\nEssai 2 : 61\nPerdu !\nEssai 3 : 62\nPerdu !\nEssai 4 : 63\nPerdu !\nEssai 5 : 67\nPerdu !\nEssai 6 : 56\nPerdu !\nEssai 7 : 51\nPerdu !\nEssai 8 : 73\nPerdu !\nEssai 9 : 71\nPerdu !\nEssai 10 : 36\nGagn\u00e9 !!!\n</code></pre> Correction <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\n// Les constantes...\n#define BORNE_MIN   3\n#define BORNE_MAX  42\n#define NB_ESSAIS   7\n\nint main() {\n\n    srand(time(NULL));\n\n    // ...qu'il ne faut pas oublier de modifier partout...\n    int nombreATrouver = rand() % BORNE_MAX + BORNE_MIN, nombreSaisi, i = 1;\n\n    // ...partout...\n    printf(\"Devine un nombre entre %d et %d (%d essai%s max.) !\", \n        BORNE_MIN, \n        BORNE_MAX, \n        NB_ESSAIS,\n        NB_ESSAIS == 1 ? \"\" : \"s\"\n    );\n\n    // ...partout...\n    do {\n\n        printf(\"\\nEssai %d : \", i);\n        scanf(\"%d\", &amp;nombreSaisi);\n\n        if (nombreSaisi == nombreATrouver) {\n            printf(\"Gagne !!!\\n\");\n        }\n\n        printf(\"Perdu !\");\n        i++;\n    } while(i &lt;= NB_ESSAIS &amp;&amp; nombreSaisi != nombreATrouver);\n\n    // ...partout !\n    if (i &gt; NB_ESSAIS) {\n        printf(\" C'etait %d !\", nombreATrouver);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/30-boucles/#bonus","title":"Bonus","text":"<p>Dessiner un sapin de No\u00ebl form\u00e9 d'\u00e9toiles :</p> <pre><code>&gt; ./sapin.exe\nNombre d'\u00e9tages : 5\n\n    *\n   ***\n  *****\n *******\n*********\n    *\n</code></pre> <p>Le nombre d'\u00e9tages est donn\u00e9 par l'utilisateur.</p> Correction <p>En observant, on note le nombre d'\u00e9toiles \u00e0 chaque \u00e9tage en les num\u00e9rotant de mani\u00e8re informatique :</p> <ul> <li> <p>Etage 0 : 1</p> </li> <li> <p>Etage 1 : 3</p> </li> <li> <p>Etage 2 : 5</p> </li> <li> <p>Etage 3 : 7</p> </li> <li> <p>Etage 4 : 9</p> </li> </ul> <p>si on g\u00e9n\u00e9ralise : <code>nbEtoiles = 2 * nbEtage + 1</code></p> <p>En observant (toujours), on note le nombre d'espaces \u00e0 chaque \u00e9tage :</p> <ul> <li> <p>Etage 0 : 4</p> </li> <li> <p>Etage 1 : 3</p> </li> <li> <p>Etage 2 : 2</p> </li> <li> <p>Etage 3 : 1</p> </li> <li> <p>Etage 4 : 0</p> </li> </ul> <p>si on g\u00e9n\u00e9ralise : <code>nbEspaces = nbEtagesTotal - nbEtage</code></p> <p>Il nous faut dont une boucle pour travailler \u00e9tage par \u00e9tage : \u00e0 l'int\u00e9rieur de laquelle, il faut une boucle pour afficher les espaces un par un, puis une autre boucle pour les \u00e9toiles.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int nbEtages = 0;\n\n    system(\"chcp 65001\");\n    system(\"cls\");\n\n    // Saisie du nombre d'\u00e9tages\n    while (nbEtages &lt;= 0) {\n        printf(\"Nombre d'\u00e9tages : \");\n        scanf(\"%d\", &amp;nbEtages);\n    }\n\n    printf(\"\\n\");\n\n    // Boucle pour les \u00e9tages\n    for (int i = 0; i &lt; nbEtages; i++) {\n        // Boucle pour les espaces\n        for (int j = 0; j &lt; nbEtages - i; j++) {\n            printf(\" \");\n        } \n        // Boucle pour les \u00e9toiles\n        for (int j = 0; j &lt; 2 * i + 1; j++) {\n            printf(\"*\");\n        }\n        // Passage \u00e0 la ligne\n        printf(\"\\n\");\n    }\n\n    // Et le tronc !!? Comme le 1er \u00e9tage !\n    for (int i = 0; i &lt; nbEtages; i++) {\n        printf(\" \");\n    } \n    printf(\"*\\n\");\n\n    printf(\"\\n\ud83c\udf81\ud83c\udf81\ud83c\udf81 \ud83c\udf84 Joyeux No\u00ebl \ud83c\udf85 \ud83c\udf81\ud83c\udf81\ud83c\udf81\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-1/40-fonctions/","title":"Usage courant","text":""},{"location":"bts-1/40-fonctions/#exercice-1","title":"Exercice 1","text":"<p>D\u00e9clarer (= proposer un prototype) les fonctions suivantes :</p> Conseils <ol> <li> <p>Identifier les entr\u00e9es de la fonction. Que va-t-on devoir lui fournir comme valeurs en entr\u00e9e pour qu'elle puisse fonctionner ? Si ces valeurs viennent d'une autre partie du programme, alors il faut un param\u00e8tre par information. Si la fonction les r\u00e9cup\u00e9rer toute seule (en appelant une autre fonction), pas besoin de param\u00e8tres.</p> </li> <li> <p>Identifier les sorties de la fonction. Doit-elle retourner quelquechose au programme qui l'appelle ? Si oui, il faut que son type retour soit en ad\u00e9quation avec la valeur retourn\u00e9e, sinon elle peut ne rien renvoyer.</p> </li> </ol> <ul> <li>Une fonction qui affiche l'heure du syst\u00e8me (qu'on r\u00e9cup\u00e8re via une fonction).</li> </ul> Solution <p>Entr\u00e9es : Aucune, si on peut r\u00e9cup\u00e9rer l'heure avec une fonction, on a besoin de rien.</p> <p>Sorties : On ne nous demande que d'afficher une donn\u00e9e, donc rien \u00e0 renvoyer.</p> <p><code>void afficher_heure();</code></p> <ul> <li>Une fonction qui affiche la table de multiplication d'un chiffre qui lui est pass\u00e9 en param\u00e8tre.</li> </ul> Solution <p>Entr\u00e9es : On a besoin du chiffre dont on doit afficher la table, donc un entier.</p> <p>Sorties : On ne nous demande que d'afficher une donn\u00e9e, donc rien \u00e0 renvoyer.</p> <p><code>void displayMultiplicationTable(int);</code></p> <ul> <li>Une fonction qui affiche le r\u00e9sultat de la somme de deux entiers pass\u00e9s en param\u00e8tres.</li> </ul> Solution <p>Entr\u00e9es : On a besoin des deux entiers qu'on doit additionner.</p> <p>Sorties : On ne nous demande que d'afficher une donn\u00e9e, donc rien \u00e0 renvoyer.</p> <p><code>void affichageSomme(int, int);</code></p> <ul> <li>Une fonction qui renvoie le r\u00e9sultat de la somme de deux r\u00e9els pass\u00e9s en param\u00e8tres.</li> </ul> Solution <p>Entr\u00e9es : On a besoin des deux r\u00e9els qu'on doit additionner.</p> <p>Sorties : On doit renvoyer le r\u00e9sultat de la somme de deux r\u00e9els qui doit donc \u00eatre... un r\u00e9el.</p> <p><code>float add(float, float);</code></p> <ul> <li>Une fonction qui demande de saisir deux nombres, les multiplie, affiche le r\u00e9sultat et le renvoie.</li> </ul> Solution <p>Entr\u00e9es : Si la fonction demande la saisie (scanf) des deux nombres pas besoin de donn\u00e9es en entr\u00e9e.</p> <p>Sorties : Il faut renvoyer le produit de deux nombres dont on ne conna\u00eet pas la nature. Qui peut le plus peut le moins : mettons un <code>double</code> ! </p> <p><code>double multiplie();</code></p> <ul> <li>Une fonction qui renvoie le r\u00e9sultat de la division de deux r\u00e9els pass\u00e9s en param\u00e8tres.</li> </ul> Solution <p>Entr\u00e9es : On a besoin des deux r\u00e9els.</p> <p>Sorties : On doit renvoyer le r\u00e9sultat de la division de deux r\u00e9els qui doit donc \u00eatre... un r\u00e9el.</p> <p><code>float division(float, float);</code></p> <ul> <li>Une fonction qui demande \u00e0 l'utilisateur de saisir une liste de 10 entiers et renvoie le plus grand.</li> </ul> Solution <p>Entr\u00e9es : La fonction g\u00e8re la saisie, besoin de rien en entr\u00e9e.</p> <p>Sorties : Le plus grand entier. Si on met un <code>int</code>, on s'assurera de lire des <code>int</code> dans le corps de la fonction.</p> <p><code>int getMax();</code></p> <ul> <li>Une fonction qui renvoie le plus grand des 10 entiers pass\u00e9s en param\u00e8tres.</li> </ul> Solution <p>Entr\u00e9es : Il nous faut de quoi passer 10 entiers... Pas de tableau pour l'instant (d'ailleurs, qu'est-ce que c'est !!? \ud83e\udd14), donc 10 <code>int</code> !</p> <p>Sorties : Le plus grand entier qui sera un <code>int</code> ici.</p> <p><code>int getMaxFrom10(int, int, int, int, int, int, int, int, int, int, int);</code></p>"},{"location":"bts-1/40-fonctions/#exercice-2","title":"Exercice 2","text":"<p>D\u00e9finir la fonction <code>minimum</code> qui prend en param\u00e8tres deux entiers et renvoie le premier s\u2019il est strictement inf\u00e9rieur au second, sinon renvoie le second.</p> <p>Ecrire un programme de test.</p> <p>Le prototype :</p> <pre><code>int minimum(int, int);\n</code></pre> Solution <pre><code>#include &lt;stdio.h&gt;\n\nint minimum(int, int);\n\nint main() {\n\n    printf(\"%d\\n\", minimum(5, 4));  // doit afficher 4\n    printf(\"%d\\n\", minimum(7, 20)); // doit afficher 7\n    printf(\"%d\\n\", minimum(5, 5));  // doit afficher 5\n\n    return 0;\n}\n\nint minimum(int a, int b) {\n    if (a &lt; b) {\n        return a;\n    }\n    else {\n        return b;\n    }\n}\n/*\n// Ecriture en une ligne :\nint minimum(int a, int b) {\n    return a &lt; b ? a : b ;\n}\n*/\n</code></pre>"},{"location":"bts-1/40-fonctions/#exercice-3","title":"Exercice 3","text":"<p>A faire sur papier</p> <p>Indiquer pour chacune des fonctions ci-dessous si elles sont correctement d\u00e9finies et, si ce n\u2019est pas le cas, expliquer l\u2019anomalie.</p> <pre><code>// Fonction 1\nfloat division (float a, float b) {\n    if (b != 0) {\n        return a / b;\n    }\n}\n\n// Fonction 2\nfloat division (float a, float b) {\n    if (b != 0) {\n        return a / b;\n    }\n    return \"Erreur !\";\n}\n\n// Fonction 3\nfloat division (float a, float b) {\n    if (b != 0) {\n        return a / b;\n    }\n    printf(\"Erreur !\");\n    return 0;\n}\n</code></pre> Solution <p>Fonction 1 : Si l\u2019ex\u00e9cution ne passe pas dans le <code>if</code>, si <code>b</code> est \u00e9gal \u00e0 0, il n\u2019y a pas de <code>return</code>. Cela ne va pas g\u00eaner le compilateur, mais \u00e0 l\u2019ex\u00e9cution, dans ce cas, n\u2019importe quelle valeur sera renvoy\u00e9e\u2026 </p> <p>Fonction 2 : Ici, si <code>b</code> est \u00e9gal \u00e0 0, on renvoie <code>\"Erreur !\"</code>, qui est une cha\u00eene de caract\u00e8res, ce qui ne correspond pas au type retour de la fonction. Cette fois, le programme ne compilera pas.</p> <p>Fonction 3 : Cette fonction est correctement d\u00e9clar\u00e9e.</p>"},{"location":"bts-1/40-fonctions/#exercice-4","title":"Exercice 4","text":"<p>Soit le programme suivant :</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int s, a = 1, b = 3 ;\n    s = somme(a, b);\n    printf(\"%d + %d = %d\\n\", a, b, s);\n    return 0;\n}\n</code></pre> <p>D\u00e9clarer et d\u00e9finir la fonction <code>somme</code> qui effectue la somme des valeurs pass\u00e9es en arguments.</p> Solution <pre><code>#include &lt;stdio.h&gt;\n\n// D\u00e9claration\nint somme(int, int);\n\nint main() {\n    int s, a = 1, b = 3 ;\n    s = somme(a, b);\n    printf(\"%d + %d = %d\\n\", a, b, s);\n    return 0;\n}\n\n// D\u00e9finition\nint somme(int x, int y) {\n    return x + y;\n}\n</code></pre>"},{"location":"bts-1/40-fonctions/#exercice-5","title":"Exercice 5","text":"<p>Ecrire une fonction qui, pour des valeurs de a, b et x saisies par l\u2019utilisateur, calcule le r\u00e9sultat de :</p> \\[ ax^3 + 2 ax^2 + b \\] <pre><code>&gt; ./exo.exe\nValeurs de a, b, x : 3, 0, 1\n= 9\nValeurs de a, b, x : 0, 2, 2\n= 2\n</code></pre> Solution <pre><code>#include &lt;stdio.h&gt;\n\n// D\u00e9claration\nint fonction(int, int, int);\n\nint main() {\n    int a, b, x;\n\n    printf(\"Valeurs de a, b, x : \");\n    scanf(\"%d, %d, %d\", &amp;a, &amp;b, &amp;x);\n\n    printf(\"= %d\\n\", fonction(a, b, x));\n\n    return 0;\n}\n\n// D\u00e9finition\nint fonction(int a, int b, int x) {\n    return a*x*x*x + 2*a*x*x + b;\n}\n</code></pre>"},{"location":"bts-1/40-fonctions/#exercice-6","title":"Exercice 6","text":"<ol> <li> <p>Ecrire une fonction <code>estPair</code> qui renvoie vrai si le nombre qui lui est pass\u00e9 est\u2026 pair \ud83d\ude0e.</p> </li> <li> <p>Ecrire une fonction <code>impairEntreBornes</code> qui affiche les nombres impairs entre 2 bornes en utilisant la fonction <code>estPair</code>.</p> </li> <li> <p>Ecrire un programme de test.</p> </li> <li> <p>Installer l'extension Doxygen Documentation Generator, puis commenter les fonctions en utilisant le format Doxygen (Commencer \u00e0 taper <code>/**</code> juste au dessus d'une fonction \ud83e\udd29).</p> </li> </ol> Aller plus loin <p>Proposer au moins une autre version de la fonction <code>impairEntreBornes</code> en utilisant toujours la fonction <code>estPair</code>.</p> Solution <pre><code>#include &lt;stdio.h&gt;\n\nint estPair(int);\nvoid impairEntreBornes(int, int);\nvoid impairEntreBornes2(int, int);\n\nint main() {\n\n    // 4 exemples qui doivent afficher le m\u00eame r\u00e9sult : 3 5 7 9 11\n\n    impairEntreBornes(3, 11); \n    impairEntreBornes(2, 12); \n\n    impairEntreBornes2(3, 11); \n    impairEntreBornes2(2, 12); \n\n    return 0;\n}\n\n/**\n* @brief Dit si la variable n est paire\n* \n* @param n la variable dont on veut conna\u00eetre la parit\u00e9\n* @return int vrai (1) si n est pair, faux(0) sinon. \n*/\nint estPair(int n) {\n    return n % 2 == 0;\n}\n\n/**\n* @brief affiche les nombres impairs entre 2 bornes\n* \n* @param debut  la borne de d\u00e9but\n* @param fin    la borne de fin\n*/\nvoid impairEntreBornes(int debut, int fin) {\n    for (int i = debut; i &lt;= fin; i++) {\n        if (!estPair(i)) {\n            printf(\"%d \", i);\n        }\n    }\n    printf(\"\\n\");\n}\n\n/**\n* @brief affiche les nombres impairs entre 2 bornes\n* \n* @param debut  la borne de d\u00e9but\n* @param fin    la borne de fin\n*/\nvoid impairEntreBornes2(int debut, int fin) {\n    if (estPair(debut)) {\n        debut++;\n    }\n    for (int i = debut; i &lt;= fin; i += 2) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\");\n}\n</code></pre>"},{"location":"bts-1/40-fonctions/#exercice-7","title":"Exercice 7","text":"<p>Ecrire un programme de calculatrice \"simple\" :</p> <pre><code>&gt; ./exo4.exe\n1 + 2\n= 3\n\n3 / 4\n= 0.750000\n\n55 * 56\n= 3080\n\n7 - 12\n= -5\n</code></pre> <ol> <li> <p>D\u00e9clarer les fonctions qui affichent le r\u00e9sultat des 4 op\u00e9rations : addition, soustraction, multiplication et division.</p> </li> <li> <p>D\u00e9finir les 4 fonctions.</p> </li> <li> <p>Faire appel aux 4 fonctions dans une fonction principale capable de lire des calculs tant que le programme n\u2019est pas interrompu.</p> </li> </ol> Aller plus loin <ol> <li> <p>Si ce n'est pas le cas, g\u00e9rer la saisie de nombres \u00e0 virgule flottante.</p> </li> <li> <p>Proposer un syst\u00e8me pour reprendre le r\u00e9sultat du calcul pr\u00e9c\u00e9dent dans le calcul suivant.</p> </li> </ol> Solution <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nfloat addition(float, float);\nfloat soustraction(float, float);\nfloat multiplication(float, float);\nfloat division(float, float);\nfloat calcul(float, char, float);\n\nint main() {\n    float operande1, operande2;\n    char operateur;\n\n    while (1) {\n        scanf(\"%f %c %f\", &amp;operande1, &amp;operateur, &amp;operande2);\n        printf(\"= %f\\n\\n\", calcul(operande1, operateur, operande2));\n    }\n\n    return 0;\n}\n\nfloat calcul(float operande1, char operateur, float operande2) {\n    float result;\n    switch(operateur) {\n        case '+' : \n            return addition(operande1, operande2); \n        case '-' : \n            return soustraction(operande1, operande2); \n        case '*' : \n            return multiplication(operande1, operande2); \n        case 'x' : \n            return multiplication(operande1, operande2); \n        case '/' : \n            return division(operande1, operande2);\n        default :\n            printf(\"! Erreur : operateur inconnu !\");\n            exit(0);\n        }\n}\n\nfloat addition(float a, float b) {\n    return a + b;\n}\n\nfloat soustraction(float a, float b) {\n    return a - b;\n}\n\nfloat multiplication(float a, float b) {\n    return a * b;\n}\n\nfloat division(float a, float b) {\n    return a / b;\n}\n</code></pre>"},{"location":"bts-2/00-waitforit/","title":"Wait for it...","text":""},{"location":"bts-2/01-poo-1/","title":"Premiers pas en POO","text":""},{"location":"bts-2/01-poo-1/#cours","title":"Cours","text":""},{"location":"bts-2/01-poo-1/#exercice-0","title":"Exercice 0","text":"<p>Reprendre le code du cours (classe Point).</p> Solution <p> exo0/Point.h</p> <pre><code>#ifndef Point_H\n#define Point_H\n\nclass Point {\n    public :\n        int x;\n        int y;\n        char lettre;\n        void afficher();\n};\n\n#endif\n</code></pre> <p> exo0/Point.cpp</p> <pre><code>#include &lt;iostream&gt;\n#include \"Point.h\"\n\nvoid Point::afficher() {\n    std::cout &lt;&lt; lettre &lt;&lt; \"(\" &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; \")\\n\";\n}\n</code></pre> <p> exo0/main.cpp</p> <pre><code>#include \"Point.h\"\n\nint main() {\n    Point p1, p2;\n    p1.x = 5;\n    p1.y = 2;\n    p1.lettre = 'A';    \n    p1.afficher(); \n    p2.x = 3;\n    p2.y = -6;\n    p2.lettre = 'B';    \n    p2.afficher();\n    p1.afficher();        \n    return 0;\n}\n</code></pre> <p>Compilation : <code>g++ exo0/*.cpp -o exo0.exe</code></p> <p>Transformer la classe pour quelle respecte l'encapsulation.</p> Solution <p> exo0/Point.h</p> <pre><code>#ifndef Point_H\n#define Point_H\n\nclass Point {\n    private :\n        int x;\n        int y;\n        char lettre;\n    public :\n        void setX(int _x);\n        void setY(int _y);\n        void setLettre(char _lettre);\n        int getX();\n        int getY();\n        char getLettre();\n        void afficher();\n};\n\n#endif\n</code></pre> <p> exo0/Point.cpp</p> <pre><code>#include &lt;iostream&gt;\n#include \"Point.h\"\n\nvoid Point::afficher() {\n    std::cout &lt;&lt; lettre &lt;&lt; \"(\" &lt;&lt; x &lt;&lt; \",\" &lt;&lt; y &lt;&lt; \")\\n\";\n}\n\nvoid Point::setX(int _x) {\n    x = _x;\n}\n\nvoid Point::setY(int _y) {\n    y = _y;\n}\n\nvoid Point::setLettre(char _lettre) {\n    lettre = _lettre;\n}\n\nint Point::getX() {\n    return x;\n}\n\nint Point::getY() {\n    return y;\n}\n\nchar Point::getLettre() {\n    return lettre;\n}\n</code></pre> <p> exo0/main.cpp</p> <pre><code>#include \"Point.h\"\n\nint main() {\n    Point p1, p2;\n    p1.setX(5);\n    p1.setY(2);\n    p1.setLettre('A');\n    p1.afficher(); \n    p2.setX(3);\n    p2.setY(-6);\n    p2.setLettre('B');\n    p2.afficher();\n    p1.afficher();        \n    return 0;\n}\n</code></pre>"},{"location":"bts-2/01-poo-1/#exercice-1","title":"Exercice 1","text":"<p>D\u00e9clarer en C++ la classe correspondant au diagramme suivant :</p> <p></p> Solution <pre><code>#ifndef IntRange_H\n#define IntRange_H\n\nclass IntRange {\n    private :\n        int value;\n        int min;\n        int max;\n        void setValue(int _value);\n    public :\n        void Initialiser();\n        void Initialiser(int _min, int _max);\n        void Initialiser(int _min, int _max, int _value);\n        int getValue();\n};\n\n#endif\n</code></pre>"},{"location":"bts-2/01-poo-1/#exercice-2","title":"Exercice 2","text":"<p>Compl\u00e9ter la classe C++ suivante :</p> <pre><code>______ DataBase {\n    _______ :\n        string server;\n        int port;\n        string login;\n        ______ password;\n        string name;\n    public :\n        void init(string _server, int _port, string _login, string _password);\n        string getIp();\n        ______ getPort();\n        string getLogin();\n        string getName();\n        void setName(______ _name);\n        string getConnectionString();\n        bool connect();\n        bool check();\n};\n</code></pre> Solution <pre><code>#include &lt;string&gt;       // Pour utiliser la classe string\n\nusing namespace std;    // Pour s'affranchir des std::\n\n#ifndef DataBase_H\n#define DataBase_H\n\nclass DataBase {\n    private :\n        string server;\n        int port;\n        string login;\n        string password;\n        string name;\n    public :\n        void init(string _server, int _port, string _login, string _password);\n        string getIp();\n        int getPort();                  // Accesseur de l'attribut port\n        string getLogin();\n        string getName();\n        void setName(string _name);     // Mutateur de l'attribut name\n        string getConnectionString();\n        bool connect();\n        bool check();\n};\n\n#endif\n</code></pre> <p>D\u00e9finir en C++ \u00e0 l\u2019ext\u00e9rieur de la classe les m\u00e9thodes <code>getName()</code> et <code>setName()</code>.</p> Solution <pre><code>string DataBase::getName() {\n    return name;\n}\n\nvoid DataBase::setName(string _name) {\n    name = _name;\n}\n</code></pre>"},{"location":"bts-2/01-poo-1/#exercice-3","title":"Exercice 3","text":"<p>Dessiner le diagramme correspondant \u00e0 la classe C++ suivante dans Visual Paradigm :</p> <pre><code>class Connexion {\n    private :\n        string ip;\n        int port;\n    public :\n        void initialiser(string _ip, string port);\n        string getIp();\n        int getPort();\n        void connecter();\n}\n</code></pre> Solution <p></p>"},{"location":"bts-2/01-poo-1/#exercice-4","title":"Exercice 4","text":"<p>Corriger dans Visual Paradigm la classe suivante pour qu'elle respecte l'encapsulation :</p> <p></p> Solution <p></p>"},{"location":"bts-2/01-poo-1/#exercice-5","title":"Exercice 5","text":"<p>On souhaite g\u00e9n\u00e9rer une classe repr\u00e9sentant un compteur. Celui-ci est compos\u00e9 d'une valeur enti\u00e8re positive ou nulle, nulle \u00e0 l'origine. Il ne peut varier que par pas de 1 (incr\u00e9mentation ou d\u00e9cr\u00e9mentation). D\u00e9cr\u00e9menter un compteur nul est sans effet.</p> <ol> <li> <p>Commencer par un diagramme de classe</p> </li> <li> <p>Ecrire la classe Counter dans deux fichiers, un pour la d\u00e9claration (Counter.h) et un pour la d\u00e9finition (Counter.cpp)</p> </li> <li> <p>Ecrire un programme de test (exo5.cpp)</p> </li> </ol> Compiler plusieurs fichiers <p>Cr\u00e9er les fichiers dans un m\u00eame r\u00e9pertoire, puis les compiler avec la commande : </p> <pre><code>&gt; g++ *.cpp -o exo_5.exe\n</code></pre> Solution <p>Diagramme de classe</p> <p></p> <p>Code :</p> <p> exo5/Counter.h</p> <pre><code>#ifndef Counter_H\n#define Counter_H\n\nclass Counter {\n    private :\n        unsigned int value;\n    public :\n        Counter();\n        void increment();\n        void decrement();\n        unsigned int getValue();\n};\n\n#endif\n</code></pre> <p> exo5/Counter.cpp</p> <pre><code>#include \"Counter.h\"\n#include &lt;climits&gt;\n\nCounter::Counter() {\n    value = 0;\n}\n\nvoid Counter::increment() {\n    if (value &lt; UINT_MAX - 1) {\n        value++;\n    }\n}\n\nvoid Counter::decrement() {\n    if (value &gt; 0) {\n        value--;\n    }\n}\n\nunsigned int Counter::getValue() {\n    return value;\n}\n</code></pre> <p> exo5/main.cpp</p> <pre><code>#include &lt;iostream&gt;\n#include \"Counter.h\"\n\nusing namespace std;\n\nint main() {\n    Counter c1, c2;\n\n    cout &lt;&lt; c1.getValue() &lt;&lt; \" \" &lt;&lt; c2.getValue() &lt;&lt; endl;\n\n    for (int i = 0; i &lt; 42; i++) {\n        c1.increment();\n        if (i % 2 == 0) {\n            c2.increment();\n        }\n    }\n\n    cout &lt;&lt; c1.getValue() &lt;&lt; \" \" &lt;&lt; c2.getValue() &lt;&lt; endl;\n\n    for (int i = 0; i &lt; 42; i++) {\n        c2.decrement();\n        if (i % 2 == 0) {\n            c1.decrement();\n        }\n    }\n\n    cout &lt;&lt; c1.getValue() &lt;&lt; \" \" &lt;&lt; c2.getValue() &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/01-poo-1/#exercice-6","title":"Exercice 6","text":"<p>On veut \u00e9crire une classe Television comprenant les donn\u00e9es membres suivantes :</p> <ul> <li>status (\"On\"/\"Off\")</li> <li>volume (0 &lt;-&gt; 50)<ul> <li>Le volume ne peut pas aller au-del\u00e0 des limites.</li> </ul> </li> <li>channel (1 &lt;-&gt; 100)<ul> <li>Les cha\u00eenes bouclent.</li> </ul> </li> </ul> <p>Le but est d\u2019encapsuler dans une classe des m\u00e9thodes permettant de manipuler un objet <code>Television</code>.</p> <p>A la cr\u00e9ation, l\u2019objet <code>Television</code> est \u00e9teint avec le volume \u00e0 0 et sur la cha\u00eene 1.</p> <ol> <li> <p>D\u00e9finir les m\u00e9thodes que vous devez impl\u00e9menter dans votre classe (mettez vous en situation d\u2019utilisateur de la classe, les m\u00e9thodes doivent \u00eatre pratiques et avoir un nom explicite).</p> </li> <li> <p>Repr\u00e9senter la classe en UML.</p> </li> <li> <p>Ecrire le code de ces m\u00e9thodes. La d\u00e9claration et la d\u00e9finition de la classe (fonctions membres) seront dans des fichiers s\u00e9par\u00e9s (Television.h et Television.cpp).</p> </li> </ol> Correction <p>Diagramme de classe</p> <p></p> <p> exo6/Television.h</p> <pre><code>// Television.h\n#ifndef TELEVISION_H\n#define TELEVISION_H\n\n#include &lt;string&gt;\n\nusing namespace std;\n\nclass Television {\n    private :\n        bool status;\n        int volume;\n        int channel;\n        void reset();\n\n    public :\n        Television();\n        void start();\n        void stop();\n        void channelUp();\n        void channelDown();\n        void volumeUp();\n        void volumeDown();\n        string display();\n};\n\n#endif\n</code></pre> <p> exo6/Television.cpp</p> <pre><code>// Television.cpp\n#include \"Television.h\"\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nTelevision::Television() {\n    reset();\n}\n\nvoid Television::start() {\n    status = true;\n}\n\nvoid Television::stop() {\n    reset();\n}\n\nvoid Television::reset() {\n    status = false;\n    channel = 1;\n    volume = 0;\n}\n\nvoid Television::channelUp() {\n    if (status) {\n        if (channel &lt; 100) {\n            channel++;\n        }\n        else {\n            channel = 1;\n        }\n    }\n}\n\nvoid Television::channelDown() {\n    if (status) {\n        if (channel &gt; 1) {\n            channel--;\n        }\n        else {\n            channel = 100;\n        }\n    }\n}\n\nvoid Television::volumeUp() {\n    if (status) {\n        if (volume &lt; 50) {\n            volume++;\n        }\n    }\n}\n\nvoid Television::volumeDown() {\n    if (status) {\n        if (volume &gt; 0) {\n            volume--;\n        }\n    }\n}\n\nstd::string Television::display() {\n    string display = \"[TV] \";\n    if (status) {\n        display += \" status : \";\n        display += status ? \"on\" : \"off\";\n        display += \" | volume : \" + to_string(volume);\n        display += \" | channel : \" + to_string(channel);\n    }\n    display += \"\\n\";\n    return display;\n}\n</code></pre> <p> exo6/main.cpp</p> <pre><code>// exo6.cpp\n#include &lt;iostream&gt;\n#include \"Television.h\"\n\nusing namespace std;\n\nint main() {\n\n    Television tv;\n\n    cout &lt;&lt; tv.display();\n    tv.channelUp();\n    tv.volumeUp();\n    cout &lt;&lt; tv.display();\n    tv.start();\n    tv.channelUp();\n    tv.volumeUp();\n    tv.volumeUp();\n    tv.volumeUp();\n    cout &lt;&lt; tv.display();\n    tv.stop();\n    cout &lt;&lt; tv.display();\n}\n</code></pre>"},{"location":"bts-2/01-poo-1/#exercice-7","title":"Exercice 7","text":"<p>Ecrire une classe Fraction :</p> <ul> <li> <p>Cette classe contient un num\u00e9rateur et un d\u00e9nominateur dont les valeurs par d\u00e9faut sont \u00e9gales \u00e0 1.</p> </li> <li> <p>On pourra instancier un objet Fraction en sp\u00e9cifiant num\u00e9rateur et d\u00e9nominateur ou en ne sp\u00e9cifiant que le num\u00e9rateur.</p> </li> <li> <p>On pourra afficher la Fraction sous la forme num\u00e9rateur/d\u00e9nominateur.</p> </li> <li> <p>On mettra en place les accesseurs n\u00e9cessaires.</p> </li> <li> <p>On pourra additionner deux objets Fraction et obtenir le r\u00e9sultat sous la forme d'un troisi\u00e8me objet Fraction.</p> </li> </ul> <p>Votre mission :</p> <ol> <li> <p>Repr\u00e9senter la classe en UML.</p> </li> <li> <p>Ecrire le code de la classe dans des fichiers s\u00e9par\u00e9s et un programme de d\u00e9monstration.</p> </li> </ol> Aller plus loin <p>Simplifier la fraction obtenue lors de l'addition.</p> Indice \\[ \\frac{a}{b}+\\frac{c}{d}=\\frac{a*d+c*b }{b*d} \\] Correction <p>Diagramme de classe</p> <p></p> <p>En utilisant la fonctionnalit\u00e9 des valeurs par d\u00e9faut des param\u00e8tres du C++, on peut passer de la d\u00e9finition de gauche \u00e0 celle de droite.</p> <p> exo7/Fraction.h</p> <pre><code>#ifndef FRACTION_H\n#define FRACTION_H\n\nclass Fraction {\n    private :\n        int numerateur, denominateur;\n        void simplifier();\n\n    public :\n        Fraction(int = 1, int = 1); // Utilisation des valeurs par d\u00e9faut pour les param\u00e8tres\n        void afficher();\n        Fraction additionner(Fraction);\n};\n\n#endif\n</code></pre> <p> exo7/Fraction.cpp</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include \"Fraction.h\"\n\nFraction::Fraction(int _numerateur, int _denominateur) {\n    numerateur = _numerateur;\n    denominateur = _denominateur;\n}\n\nvoid Fraction::afficher() {\n    std::cout &lt;&lt; numerateur &lt;&lt; \"/\" &lt;&lt; denominateur &lt;&lt; std::endl;\n}\n\nFraction Fraction::additionner(Fraction _f) {\n    Fraction r;\n\n    // Calcul\n    r.numerateur = numerateur * _f.denominateur + _f.numerateur * denominateur;\n    r.denominateur = denominateur * _f.denominateur;\n\n    // Simplification\n    r.simplifier();\n\n    return r;\n}\n\nvoid Fraction::simplifier() {\n    int a, b, temp;\n\n    // Solution 1 : Calcul du PGCD avec la fonction standard\n    // a = std::gcd(r.numerateur, r.denominateur);\n\n    // Solution 2 : Calcul du PGCD avec l'algo d'Euclide (https://fr.wikipedia.org/wiki/Algorithme_d%27Euclide)\n    a = numerateur, b = denominateur;\n    while (b != 0) {\n        temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    // Simplification\n    numerateur /= a;\n    denominateur /= a;\n}\n</code></pre> <p> exo7/main.cpp</p> <pre><code>#include \"Fraction.h\"\n\nint main() {\n    Fraction f1, f2(2), f3(1, 3), f4(2, 3);\n\n    f1.afficher();\n    f2.afficher();\n    f3.afficher();\n    f4.afficher();\n\n    f2.additionner(f3).afficher();                  // 2 + 1/3 = 7/3\n    f1.additionner(f2).afficher();                  // 1 + 2 = 3/1\n    f2.additionner(f3).additionner(f4).afficher();  // 2 + 1/3 + 2/3 = 27/9 = 3/1\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/01-poo-1/#exercice-8","title":"Exercice 8","text":"<p>Modifier le fichier Sailor.cpp pour que le programme suivant affiche  :</p> <pre><code>&gt; ./exo8.exe\nnom : noname\nnom : paul\nnom : eric\nnom : fred\nnom : xavier\nnombre de Sailors : 5\n</code></pre> <pre><code>// Sailor.h\n#ifndef SAILOR_H\n#define SAILOR_H\n\n#include &lt;string&gt;\n\nclass Sailor {\n    private :\n        std::string name;\n        static int sailorsCount;\n    public :\n        Sailor(std::string);\n        Sailor();\n        ~Sailor();\n        int getSailorsCount();\n        void setName(std::string);\n        void display();\n};\n\n#endif\n</code></pre> <pre><code>// Sailor.cpp\n#include \"Sailor.h\"\n\n! A COMPLETER !\n</code></pre> <pre><code>// exo8.cpp\n#include &lt;iostream&gt;\n#include \"Sailor.h\"\n\nint main() {\n    Sailor sailor1;\n    Sailor sailor2(\"paul\");\n    Sailor bateau1[3];\n\n    sailor1.display();\n    sailor2.display();\n\n    bateau1[0].setName(\"eric\");\n    bateau1[1].setName(\"fred\");\n    bateau1[2].setName(\"xavier\");\n\n    for (int i = 0; i &lt; 3; i++) {\n        bateau1[i].display();\n    }\n\n    std::cout &lt;&lt; \"nombre de sailors : \" &lt;&lt; sailor1.getSailorsCount();\n\n    return 0;\n}\n</code></pre> Correction <p> exo8/Sailor.cpp</p> <pre><code>// Sailor.cpp\n#include \"Sailor.h\"\n#include &lt;iostream&gt;\n\nint Sailor::sailorsCount = 0;\n\nSailor::Sailor(std::string _name) {\n    name = _name;\n    sailorsCount++;\n}\n\nSailor::Sailor() {\n    name = \"noname\";\n    sailorsCount++;\n}\n\nSailor::~Sailor() {\n    sailorsCount--;\n}\n\nint Sailor::getSailorsCount() {\n    return sailorsCount;\n}\n\nvoid Sailor::setName(std::string _name) {\n    name = _name;\n}\n\nvoid Sailor::display() {\n    std::cout &lt;&lt; \"nom : \" &lt;&lt; name &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"bts-2/10-du-c-au-cpp/","title":"01 - Du C au C++","text":""},{"location":"bts-2/10-du-c-au-cpp/#cours","title":"Cours","text":""},{"location":"bts-2/10-du-c-au-cpp/#exercice-0","title":"Exercice 0","text":"<p>Ecrire un programme en C++ qui affiche <code>hello, world!</code></p> Indice <p>Trame de base d'un programme en C++</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n\n}\n</code></pre> Indice <p>Compilation</p> <pre><code>&gt; g++ exo0.cpp -o exo.exe\n</code></pre> Correction <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"hello, world!\";\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/10-du-c-au-cpp/#exercice-1","title":"Exercice 1","text":"<p>Ecrire un programme en C++ qui calcule la racine carr\u00e9e de nombres fournis par l'utilisateur. </p> <p>Il refusera les valeurs n\u00e9gatives et s'arr\u00eatera si on lui fournit 0.</p> Indice <p>Proc\u00e9der par \u00e9tapes</p> Indice <ol> <li> <p>Ecrire un programme en C++ qui lit et affiche une saisie num\u00e9rique de l\u2019utilisateur</p> </li> <li> <p>Compl\u00e9ter en ajoutant le test pour les valeurs n\u00e9gatives</p> </li> <li> <p>Compl\u00e9ter en affichant la racine carr\u00e9e</p> </li> <li> <p>Compl\u00e9ter en ajoutant la boucle qui s\u2019arr\u00eate si on saisit 0</p> </li> </ol> Indice <p><code>sqrt()</code> est dans la biblioth\u00e8que cmath.</p> Correction <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\nint main() {\n    int input;\n\n    system(\"chcp 65001\");\n    system(\"cls\");\n\n    cout &lt;&lt; endl &lt;&lt; \"-= Calcul de racine carr\u00e9e =-\" &lt;&lt; endl &lt;&lt; endl;\n\n    cout &lt;&lt; \"Entrer 0 pour quitter.\" &lt;&lt; endl &lt;&lt; endl;\n\n    do {\n\n        cout &lt;&lt; \"Entrer une valeur positive : \";\n        cin &gt;&gt; input;\n        if (input &lt; 0) {\n            cout &lt;&lt; \"J'ai dit P-O-S-I-T-I-V-E !!!\" &lt;&lt; endl &lt;&lt; endl;\n            continue;\n        }\n        if (input &gt; 0) {\n            cout &lt;&lt; \"Racine carr\u00e9e : \" &lt;&lt; sqrt(input) &lt;&lt; endl &lt;&lt; endl;\n        }\n    }\n    while(input != 0);\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/10-du-c-au-cpp/#exercice-2","title":"Exercice 2","text":"<p>Ecrire deux fonctions de swap utilisant :</p> <ol> <li>le passage par adresse</li> <li>le passage par r\u00e9f\u00e9rence</li> </ol> <p>et le programme principal de test les utilisant en C++.</p> <p>Nommer les fonctions \"echange\".</p> Aller plus loin <p>Trouver une m\u00e9thode de swap sans utiliser de 3<sup>\u00e8me</sup> variable.</p> Correction <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Passage par adresse\nvoid echange(int * x, int * y) {\n    int z = *x;\n    *x = *y;\n    *y = z;\n}\n\n// Passage par r\u00e9f\u00e9rence\nvoid echange(int &amp; x, int &amp; y) {\n    int z = x;\n    x = y;\n    y = z;\n}\n\n// Aller plus loin\nvoid echangeSansVariableSupplementaire(int &amp; a, int &amp; b) {\n    a = a + b;\n    b = a - b;\n    a = a - b;\n}\n\nint main() {\n    int a = 42, b = -1;\n\n    cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; endl;\n    echange(a, b);\n    cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; endl;\n    echange(&amp;a, &amp;b);\n    cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; endl;\n    echangeSansVariableSupplementaire(a, b);\n    cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/10-du-c-au-cpp/#exercice-3","title":"Exercice 3","text":"<p>Ecrire une fonction qui permet de retourner le nombre de secondes en additionnant les heures, minutes et secondes qu'on lui passe en param\u00e8tres. </p> <p>Seul le param\u00e8tre des heures est obligatoire. </p> <p>Ecrire un programme de test.</p> Indice <p>Arguments optionnels</p> Correction <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Prototype avec les valeurs par d\u00e9faut\nint nombreDeSecondes(int heures, int minutes = 0, int secondes = 0);\n\nint main() {\n    cout &lt;&lt; nombreDeSecondes(1, 10, 25) &lt;&lt; endl;\n    cout &lt;&lt; nombreDeSecondes(1, 10) &lt;&lt; endl;\n    cout &lt;&lt; nombreDeSecondes(1) &lt;&lt; endl;\n    return 0;\n}\n// D\u00e9finition de la fonction, SANS les valeurs par d\u00e9faut\nint nombreDeSecondes(int heures, int minutes, int secondes) {\n    return heures * 3600 + minutes * 60 + secondes;\n}\n</code></pre>"},{"location":"bts-2/10-du-c-au-cpp/#exercice-4","title":"Exercice 4","text":"<pre><code>void fct (int);         // fonction A \nvoid fct (float);       // fonction B\nvoid fct (int, float);  // fonction C\nvoid fct (float, int);  // fonction D\n\nint main () {\n    int n, p;\n    float x, y;\n    char c;\n    double z;\n    /*\n    Les appels suivants des fonctions sont ils corrects ? \n    Si oui, quelle est la fonction appel\u00e9e et quelles sont\n    \u00e9ventuellement les conversions mises en place ?\n    */\n    fct(n);\n    fct(x);\n    fct(n, x);\n    fct(x, n);\n    fct(c);\n    fct(n, p);\n    fct(n, c);\n    fct(n, z);\n}\n</code></pre> Correction <pre><code>fct (n);    // Correct, appel de la fonction A\nfct (x);    // Correct, appel de la fonction B\nfct (n,x);  // Correct, appel de la fonction C\nfct (x,n);  // Correct, appel de la fonction D\nfct (c);    // Correct, appel de la fonction A, conversion implicite de char en int\nfct (n,p);  // Incorrect, conflit entre C et D\nfct (n,c);  // Incorrect, conflit entre C et D \nfct (n,z);  // Correct, appel de la fonction C, conversion implicite de double en float\n</code></pre>"},{"location":"bts-2/10-du-c-au-cpp/#exercice-5","title":"Exercice 5","text":"<ol> <li> <p>Ecrire une fonction qui permet d'effectuer la saisie d\u2019un tableau d'entiers qui lui est pass\u00e9 (vide) en param\u00e8tre puis l'affiche.</p> </li> <li> <p>Surd\u00e9finir cette fonction pour qu\u2019elle puisse effectuer la saisie de caract\u00e8res.</p> </li> <li> <p>Ecrire un programme de test.</p> </li> </ol> <p>Exemple :</p> <pre><code>&gt; ./exo5.exe\nSaisir 3 entiers :\n1: 23\n2: 675\n3: -33\nValeurs saisie : 23, 675, -33\n</code></pre> Indice <p>La fonction a 2 arguments.</p> Indice <pre><code>// Prototype de la fonction\nvoid remplir(int *, int);\n</code></pre> Correction <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int COUNT_INT = 5;\nconst int COUNT_CHAR = 5;\n\nvoid remplir (int *, int); \n// surdefinition de la fonction remplir\nvoid remplir (char *, int);\n\nint main() { \n    int intArray[COUNT_INT];\n    remplir(intArray, COUNT_INT);\n\n    cout &lt;&lt; endl;\n\n    char charArray[COUNT_CHAR];\n    remplir(charArray, COUNT_CHAR);\n\n    return 0;\n}\n\nvoid remplir (int * array, int count) {\n    // Remplissage\n    for (int i = 0; i &lt; count; i++) {\n        cout &lt;&lt; \"Saisissez l'entier N\u00b0 \" &lt;&lt; i + 1 &lt;&lt; \" : \";\n        cin &gt;&gt; array[i];\n    }\n    // Affichage\n    cout &lt;&lt; \"Saisie :\";\n    for (int i = 0; i &lt; count; i++) {\n        cout &lt;&lt; \" \" &lt;&lt; array[i];\n    }\n}\n\n\nvoid remplir (char * array, int count) {\n    // Remplissage\n    for (int i = 0; i &lt; count; i++) {\n        cout &lt;&lt; \"Saisissez le caract\u00e8re N\u00b0 \" &lt;&lt; i + 1 &lt;&lt; \" : \";\n        cin &gt;&gt; array[i];\n    }\n    // Affichage\n    cout &lt;&lt; \"Saisie :\";\n    for (int i = 0; i &lt; count; i++) {\n        cout &lt;&lt; \" \" &lt;&lt; array[i];\n    }\n}\n</code></pre> Aller plus loin <p>Rendre le nombre d\u2019\u00e9l\u00e9ments et le type de tableau param\u00e9trable via la ligne de commande.</p>"},{"location":"bts-2/10-du-c-au-cpp/#exercice-6","title":"Exercice 6","text":"<ol> <li> <p>Migrer le programme en C suivant en C++ en utilisant les nouvelles possibilit\u00e9s du langage.</p> </li> <li> <p>Compl\u00e9ter la fonction principale pour afficher les \"personnes\" saisies.</p> </li> <li> <p>D\u00e9placer le code de remplissage de la personne dans une fonction <code>saisiePersonne</code>.</p> </li> </ol> <pre><code>#include &lt;stdio.h&gt;\n\nstruct Personne\n{\n    char nom [30];\n    int age;\n};\n\nint main () {\n    struct Personne p[3];\n    int nbpers, i;\n    nbpers = 0;\n    //saisie des 3 personnes\n    for (i = 0; i &lt; 3; i++)\n    {\n        printf(\"Saisissez le nom de la personne N\u00b0 %d : \", i+1);\n        gets(p[i].nom);\n        printf(\"Saisissez l'age de la personne N\u00b0 %d : \", i+1);\n        scanf(\"%d\", &amp;p[i].age);\n        nbpers++;\n    }\n    printf(\"\\\\n%d personnes ont ete saisies\\\\n\", nbpers);\n\n    return 0;\n}\n</code></pre> Correction <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct Personne\n{\n    string nom;\n    int age;\n};\n\nPersonne saisiePersonne(int i) {\n    Personne indigene;\n    cout &lt;&lt; \"Saisissez le nom de la personne N\u00b0\" &lt;&lt; i + 1 &lt;&lt; \" : \";\n    cin &gt;&gt; indigene.nom;\n\n    cout &lt;&lt; \"Saisissez l'age de la personne N\u00b0\" &lt;&lt; i + 1 &lt;&lt; \" : \";\n    cin &gt;&gt; indigene.age;\n\n    return indigene;\n}\n\nint main () {\n    vector&lt;Personne&gt; p;\n\n    // Saisie des 3 personnes\n    for (int i = 0; i &lt; 3; i++)\n    {\n        p.push_back(saisiePersonne(i));\n    }\n\n    cout &lt;&lt; endl &lt;&lt; p.size() &lt;&lt; \" personnes ont ete saisies\" &lt;&lt; endl;\n\n    for (int i = 0; i &lt; p.size(); i++) {\n        cout &lt;&lt; p[i].nom &lt;&lt; \" (\" &lt;&lt; p[i].age &lt;&lt; \")\" &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/30-poo-2/","title":"03 - POO level 2","text":""},{"location":"bts-2/30-poo-2/#exercice-1","title":"Exercice 1","text":"<p>Sur la base du diagramme de classes ci-dessous, cr\u00e9er le programme qui permet de saisir les noms de plusieurs personnes puis un nombre de groupes \u00e0 cr\u00e9er. </p> <p></p> <p>Le programme se chargera ensuite de r\u00e9partir automatiquement les personnes dans les groupes. </p> <p>Finalement il affichera la composition des groupes et le groupe d'appartenance de chaque personne.</p> Indice <p>La classe <code>std::vector</code> peut \u00eatre utile.</p> Indice <p>On cr\u00e9era d'abord les personnes, puis les groupes dans le <code>main</code>.</p> <p>Ensuite on attache les personnes aux groupes et les groupes aux personnes.</p> <p>On manipulera des pointeurs pour les r\u00e9f\u00e9rences afin d'\u00e9viter les recopies d'objets.</p> <pre><code>&gt; ./exo_1.exe\nSaisir les noms des personnes \u00e0 cr\u00e9er (! pour arr\u00eater) :\n#1 : Bianca\n#2 : Tryphon\n#3 : Archibald\n#4 : Allan\n#5 : Piotr\n#6 : Tchang\n#7 : Seraphin\n#8 : !\n7 personnes saisies.\n\nNombre de groupes \u00e0 cr\u00e9er : 3\n\n1\nBianca (1)\nAllan (4)\nSeraphin (7)\n\n2\nTryphon (2)\nPiotr (5)\n\n3\nArchibald (3)\nTchang (6)\n\nBianca (1) appartient au groupe 1\nTryphon (2) appartient au groupe 2\nArchibald (3) appartient au groupe 3\nAllan (4) appartient au groupe 1\nPiotr (5) appartient au groupe 2\nTchang (6) appartient au groupe 3\nSeraphin (7) appartient au groupe 1\n</code></pre> Correction <p> exo1/person.hpp</p> <pre><code>#include &lt;string&gt;\n\n#ifndef PERSON_H\n#define PERSON_H\n\nusing namespace std;\n\nclass Group;   // On triche pour \u00e9viter une mise en abyme infinie des includes crois\u00e9s.\n\nclass Person {\n    private :\n        int id;\n        static int count;\n        string name;\n        Group * group;  // Pour \u00e9viter les recopies d'objets, on utilise un pointeur.\n\n    public:\n        Person(string);\n        void display();\n        Group * getGroup();\n        void setGroup(Group &amp;); // Le passage par r\u00e9f\u00e9rence simplifie l'utilisation de la m\u00e9thode.\n};\n\n#endif\n</code></pre> <p> exo1/person.cpp</p> <pre><code>#include \"person.hpp\"\n#include \"group.hpp\"\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint Person::count = 0;\n\nPerson::Person(string _name) {\n    name = _name;\n    count++;\n    id = count;\n}\n\nvoid Person::display() {\n    cout &lt;&lt; name &lt;&lt; \" (\" &lt;&lt; id &lt;&lt; \")\";\n}\n\nvoid Person::setGroup(Group &amp; _group) {\n    group = &amp; _group;\n}\n\nGroup * Person::getGroup() {\n    return group;\n}\n</code></pre> <p> exo1/group.hpp</p> <pre><code>#include &lt;vector&gt;\n\n#ifndef GROUP_H\n#define GROUP_H\n\nusing namespace std;\n\nclass Person;   // On triche pour \u00e9viter une mise en abyme infinie des includes crois\u00e9s.\n\nclass Group {\n    private :\n        int id;\n        vector&lt;Person *&gt; people;  // Pour \u00e9viter les recopies d'objets, on utilise des pointeurs.\n        static int count;\n\n    public :\n        Group();\n        int getId();\n        void addPerson(Person &amp;); // Le passage par r\u00e9f\u00e9rence simplifie l'utilisation de la m\u00e9thode.\n        void display();\n};\n\n#endif\n</code></pre> <p> exo1/group.cpp</p> <pre><code>#include \"group.hpp\"\n#include \"person.hpp\"\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint Group::count = 0;\n\nGroup::Group() {\n    count++;\n    id = count;\n}\n\nint Group::getId() {\n    return id;\n}\n\nvoid Group::addPerson(Person &amp; p) {\n    people.push_back(&amp;p);\n}\n\nvoid Group::display() {\n    cout &lt;&lt; id &lt;&lt; endl;\n    for (int i = 0; i &lt; people.size(); i++) {\n        people[i]-&gt;display();   // -&gt; car ce sont des pointeurs qu'on manipule\n        cout &lt;&lt; endl;\n    }\n}\n</code></pre> <p> exo1/main.cpp</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include \"person.hpp\"\n#include \"group.hpp\"\n\nusing namespace std;\n\nint main() {\n\n    vector&lt;Person&gt; allPeople;   // Un tableau pour stocker les personnes cr\u00e9\u00e9es au fur et \u00e0 mesure.\n    vector&lt;Group&gt; allGroups;    // Un tableau pour stocker les groupes cr\u00e9\u00e9s.\n\n    string input = \"\";          // Un tampon pour r\u00e9cup\u00e9rer les noms saisis.\n    int nbGroups = 0;\n\n    system(\"chcp 65001\");       // Passage de la console Windows en UTF-8\n    system(\"cls\");              // Nettoyage de la console\n\n    // Saisie\n    cout &lt;&lt; \"Saisir les noms des personnes \u00e0 cr\u00e9er (vide pour arr\u00eater) :\" &lt;&lt; endl;\n    do {\n        cout &lt;&lt; \"#\" &lt;&lt; allPeople.size() + 1 &lt;&lt; \" : \";\n\n        getline(cin, input);    // Permet d'autoriser les saisies vides.\n\n        // Cr\u00e9ation d'une nouvelle personne\n        if (input != \"\") {\n            allPeople.push_back(Person(input));\n        }\n\n    } while (input != \"\");\n\n    cout &lt;&lt; endl &lt;&lt; allPeople.size() &lt;&lt; \" personne(s) saisie(s)\" &lt;&lt; endl &lt;&lt; endl;\n\n    // Cr\u00e9ation des groupes\n    do {\n        cout &lt;&lt; \"Nombre de groupes \u00e0 cr\u00e9er : \";\n        cin &gt;&gt; nbGroups;\n    } while (nbGroups &lt;= 0);\n    for (int i = 0; i &lt; nbGroups; i++) {\n        allGroups.push_back(Group());\n    }\n\n    // R\u00e9partition des personnes dans les groupes\n    for (int i = 0; i &lt; allPeople.size(); i++) {\n        allGroups[i % nbGroups].addPerson(allPeople[i]);\n        allPeople[i].setGroup(allGroups[i % nbGroups]);\n    }\n\n    // Affichage des groupes\n    cout &lt;&lt; endl;\n    for (int i = 0; i &lt; allGroups.size(); i++) {\n        allGroups[i].display();\n        cout &lt;&lt; endl;\n    }\n    cout &lt;&lt; endl;\n\n    // Affichage des personnes\n    for (int i = 0; i &lt; allPeople.size(); i++) {\n        allPeople[i].display();\n        cout &lt;&lt; \" appartient au groupe \" &lt;&lt; allPeople[i].getGroup()-&gt;getId() &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/30-poo-2/#exercice-2","title":"Exercice 2","text":"<p>R\u00e9pondre aux questions suivantes portant sur le diagramme de classes, fruit du travail de conception d\u2019un programme de gestion d\u2019une biblioth\u00e8que.</p> <ol> <li> <p>Peut-on cr\u00e9er des utilisateurs sans sp\u00e9cifier de nom\u00a0? Expliquer.</p> Correction <p>Deux r\u00e9ponses sont acceptables, car le diagramme de classes manque de pr\u00e9cision sur ce point :</p> <pre><code>+ Non, il n'y a qu'un constructeur d\u00e9clar\u00e9 et celui-ci a deux param\u00e8tres `string` qui \"logiquement\" correspondent aux deux attributs nom et email.\n\n+ Oui, le constructeur d\u00e9clar\u00e9 a deux param\u00e8tres `string`, si l'un deux correspond au nom, alors il est possible de lui passer une cha\u00eene de caract\u00e8res vide...\n</code></pre> </li> <li> <p>Expliquer \u00e0 quoi correspondent chacun des termes et symboles de la ligne suivante : <code>isEmailValid(string) : bool</code></p> Correction <p>C'est une m\u00e9thode et les diff\u00e9rents \u00e9l\u00e9ments correspondent \u00e0 :</p> <ul> <li> <p><code>isEmailValid</code> : l'identificateur (le nom) de la m\u00e9thode ;</p> </li> <li> <p><code>(string)</code> : les param\u00e8tres de la m\u00e9thode (les donn\u00e9es en entr\u00e9e), ici une cha\u00eene de caract\u00e8res ;</p> </li> <li> <p><code>: bool</code> : le type retour de la m\u00e9thode (les donn\u00e9es en sortie), ici un bool\u00e9en.</p> </li> </ul> </li> <li> <p>Pourquoi la ligne <code>+ setEmail(string)</code> de la classe <code>Utilisateur</code> n'a pas de partie avec les <code>:</code>\u00a0?</p> Correction <p>C'est un mutateur, une m\u00e9thode qui modifie un attribut, elle ne renvoie rien, l'UML nous permet de ne pas \u00e9crire <code>: void</code>.</p> </li> <li> <p>Peut-on valider le format d\u2019un email avec la m\u00e9thode <code>isEmailValid</code> en l\u2019appelant sur un objet <code>Utilisateur</code> cr\u00e9\u00e9 dans le programme principal\u00a0? Expliquer.</p> Correction <p>Non, la m\u00e9thode <code>isEmailValid</code> est pr\u00e9c\u00e9d\u00e9e d'un signe <code>-</code> qui signifie que la m\u00e9thode est priv\u00e9e, c'est-\u00e0-dire qu'on ne peut l'appeler que depuis la classe et non en-dehors.</p> </li> <li> <p>Peut-on modifier un emprunt apr\u00e8s cr\u00e9ation\u00a0? Expliquer.</p> Correction <p>Par convention de nommage, on peut d\u00e9duire que les deux m\u00e9thodes <code>setDateRetour</code> et <code>prolonger</code> sont des mutateurs, qui permettent de modifier des attributs apr\u00e8s sa cr\u00e9ation.</p> </li> <li> <p>Doit-on cr\u00e9er un objet <code>Emprunt</code> par exemplaire emprunt\u00e9 ou un objet <code>Emprunt</code> peut-il concern\u00e9 plusieurs exemplaires d\u2019un coup\u00a0? Expliquer.</p> Correction <p>La cardinalit\u00e9 nous indique qu'un emprunt est reli\u00e9 \u00e0 un et un seul exemplaire, il faut donc cr\u00e9er un objet <code>Emprunt</code> par Exeplaire <code>emprunt\u00e9</code>.</p> </li> <li> <p>Les attributs <code>dateEmprunt</code> et <code>dateRetourPrevu</code> de la classe <code>Emprunt</code> n\u2019ont pas de mutateur et le constructeur n\u2019a pas de param\u00e8tre de type date. Qu\u2019en d\u00e9duisez-vous sur la valorisation de ces deux dates\u00a0?</p> Correction <p>Ils sont probablement g\u00e9n\u00e9r\u00e9 automatiquement dans le constructeur, la date d'emprunt serait la date du syst\u00e8me et la date retour calcul\u00e9e \u00e0 partir d'une r\u00e8gle comme il est courant d'en rencontrer dans les biblioth\u00e8ques (emprunt de 4 semaines \u00e0 Laval Agglo par exemple).</p> </li> <li> <p>De quel type est l\u2019attribut <code>emprunts</code> de la classe <code>Utilisateur</code>. Proposer deux mani\u00e8res diff\u00e9rentes de l\u2019impl\u00e9menter en C++. </p> Correction <pre><code>// Si on g\u00e8re nous-m\u00eame l'allocation dynamique :\nEmprunt * emprunts;\n\n// ou mieux :\nvector&lt;Emprunt&gt; emprunts;\n\n// \u00e0 la rigueur...\nEmprunt emprunts[];\n</code></pre> </li> <li> <p>L\u2019attribut <code>- nombre : int</code> de la classe <code>Exemplaire</code> est soulign\u00e9, qu\u2019est-ce que cela signifie\u00a0?</p> Correction <p>L'attribut est static, il est partag\u00e9 par tous les objets de la classe.</p> </li> <li> <p>Il n\u2019y a pas de mutateur pr\u00e9vu pour l\u2019attribut <code>- nombre : int</code> de la classe <code>Exemplaire</code>, comment peut-on incr\u00e9menter ou d\u00e9cr\u00e9menter cet attribut\u00a0?</p> Correction <p>C'est un attribut static, probablement pour compter le nombre d'objets <code>Exemplaire</code> dans le syst\u00e8me, donc on incr\u00e9mente probablement ce nombre dans le constructeur et d\u00e9cr\u00e9mente dans le destructeur.</p> </li> <li> <p>Comment peut-on, \u00e0 tout moment, conna\u00eetre le nombre total de documents disponibles dans la biblioth\u00e8que\u00a0?</p> Correction <p>Si l'impl\u00e9mentation propos\u00e9e \u00e0 la question pr\u00e9c\u00e9dente est bonne, alors \u00e0 tout moment, l'attribut <code>nombre</code> de la classe <code>Exemplaire</code>, contient le nombre d'objets dans le syst\u00e8me et donc de documents dans la biblioth\u00e8que. On peut en r\u00e9cup\u00e9rer la valeur avec l'instruction : <code>Exemplaire::getNombre();</code>.</p> </li> <li> <p>Pourrait-on mettre en place sur la classe <code>Emprunt</code> un attribut <code>- nombre : int</code> avec la m\u00eame caract\u00e9ristique qu\u2019\u00e0 la question 9 pour compter le nombre d\u2019emprunts d\u2019un utilisateur\u00a0? </p> <p>Si oui, que doit-on mettre en place\u00a0? </p> <p>Si non, expliquer pourquoi et indiquer comment r\u00e9aliser cette demande.</p> Correction <p>Non, si on mettait cet attribut sur la classe Emprunt, on r\u00e9cup\u00e9rerai le nombre total d'emprunts (objets <code>Emprunt</code>) dans le syst\u00e8me. On peut r\u00e9cup\u00e9rer cette information de deux mani\u00e8res, en fonction de l'impl\u00e9mentation de l'attributs <code>Uilisateur::empunts</code> \u00e0 la question 8 :</p> <ul> <li> <p>Si emprunts est un vecteur on pourra r\u00e9cup\u00e9rer le nombre d'emprunts d'un objet Utilisateur avec l'instruction : <code>u1.getEmprunts().size()</code></p> </li> <li> <p>Si emprunts est un pointeur d'Emprunt (Emprunt *), il faut cr\u00e9er un attribut pour sauvegarder la taille du tableau et un accesseur, on pourra alors r\u00e9cup\u00e9rer le nombre d'emprunts d'un objet Utilisateur en appelant cet accesseur.</p> </li> </ul> </li> <li> <p>En utilisant les m\u00e9thodes disponibles, peut-on \u00e0 partir d\u2019un objet <code>Livre</code> remonter jusqu\u2019aux utilisateurs qui en ont emprunt\u00e9 un exemplaire\u00a0? Expliquer. </p> Correction <p>Oui :</p> <ol> <li> <p>en appelant <code>getExemplaires</code> sur un objet <code>Livre</code> on r\u00e9cup\u00e8re un tableau d'exemplaires</p> </li> <li> <p>en parcurant le tableau d'exemplaires avec une boucle et en appelant <code>getEmprunt</code> sur chaque \u00e9l\u00e9ment</p> </li> <li> <p>si on ne r\u00e9cup\u00e8re pas <code>nullptr</code>, on peut appeler getUtilisateur() et r\u00e9cup\u00e9rer l'utilisateur li\u00e9 \u00e0 chaque emprunt.</p> </li> </ol> </li> <li> <p>Peut-on avoir des emplacements vides\u00a0? Pourquoi\u00a0?</p> Correction <p>La cardinalit\u00e9 de la liaison entre <code>Emplacement</code> et <code>Livre</code> nous indique que l'attribut <code>livres</code> peut contenir 0 \u00e0 n livres.</p> </li> <li> <p>Compl\u00e9ter la d\u00e9claration en C++ de la classe Emplacement. </p> <p>On supposera que les directives #include n\u00e9cessaires ont \u00e9t\u00e9 r\u00e9alis\u00e9es au pr\u00e9alable. </p> <p>Ne pas d\u00e9finir les m\u00e9thodes. </p> <p>Les tableaux d\u2019objets <code>Type</code> sont d\u00e9clar\u00e9s sous la forme d\u2019un objet <code>vector&lt;Type&gt;</code>.</p> <pre><code>class Emplacement {\n    ...\n};\n</code></pre> Correction <pre><code>class Emplacement {\n    private :\n        int niveau;\n        int etagere;\n        int travee;\n        vector&lt;Livre *&gt; livres;\n    public :\n        Emplacement(int, int, int);\n        ~Emplacement();\n        void addLivre(Livre *);\n        void removeLivre(Livre *);\n        vector&lt;Livre *&gt; getLivres();\n};\n</code></pre> </li> <li> <p>D\u00e9finir en C++ \u00e0 l\u2019ext\u00e9rieur de la d\u00e9claration de la classe <code>Livre</code> les m\u00e9thodes accesseur et mutateur de l\u2019attribut <code>titre</code>.</p> Correction <pre><code>// Accesseur\nstring Livre::getTitre() {\n    return titre;\n}\n\n// Mutateur\nvoid Livre::setTitre(string _titre) {\n    titre = _titre;\n}\n</code></pre> </li> </ol>"},{"location":"bts-2/30-poo-2/#lexercice-en-plus","title":"L'exercice en plus","text":"<p>Transformer la fable de la Fontaine suivante en \"Le Rossignol et le Kangourou\".</p> <pre><code>\"Le Corbeau et le Renard\\n\\n\"\n\"Ma\u00eetre Corbeau, sur un arbre perch\u00e9,\\n\"\n\"Tenait en son bec un fromage.\\n\"\n\"Ma\u00eetre Renard, par l'odeur all\u00e9ch\u00e9,\\n\"\n\"Lui tint \u00e0 peu pr\u00e8s ce langage :\\n\"\n\"Et bonjour, Monsieur du Corbeau.\\n\"\n\"Que vous \u00eates joli ! que vous me semblez beau !\\n\"\n\"Sans mentir, si votre ramage\\n\"\n\"Se rapporte \u00e0 votre plumage,\\n\"\n\"Vous \u00eates le Ph\u00e9nix des h\u00f4tes de ces bois.\\n\"\n\"\u00c0 ces mots, le Corbeau ne se sent pas de joie ;\\n\"\n\"Et pour montrer sa belle voix,\\n\"\n\"Il ouvre un large bec, laisse tomber sa proie.\\n\"\n\"Le Renard s'en saisit, et dit : Mon bon Monsieur,\\n\"\n\"Apprenez que tout flatteur\\n\"\n\"Vit aux d\u00e9pens de celui qui l'\u00e9coute.\\n\"\n\"Cette le\u00e7on vaut bien un fromage, sans doute.\\n\"\n\"Le Corbeau honteux et confus\\n\"\n\"Jura, mais un peu tard, qu'on ne l'y prendrait plus.\\n\\n\";\n</code></pre> <p>Toutes les mentions de la classe <code>string</code> dans cette exercice  d\u00e9signe la classe <code>std::string</code>.</p> <ol> <li> <p>Initialiser un objet <code>string</code> avec la cha\u00eene de caract\u00e8res ci-dessus.</p> </li> <li> <p>Cr\u00e9er la fonction suivante:</p> <pre><code>/**\n* @brief Remplace dans str toutes les occurences de search par replace.\n* \n* @param str La cha\u00eene d'origine\n* @param search La cha\u00eene recherch\u00e9e\n* @param replace La cha\u00eene de remplacement\n*/\nvoid replaceAll(string &amp; str, string search, string replace);\n</code></pre> <p>en utilisant seulement les m\u00e9thodes suivantes de la classe <code>string</code> :</p> <pre><code>/**\n* @brief Renvoie la longueur en octets de la cha\u00eene.\n* \n* @return int La longueur en octets de la cha\u00eene.\n*/\nint string::length();\n\n/**\n* @brief Renvoie la position dans la cha\u00eene de la premi\u00e8re occurence de str \u00e0 partir de pos.\n* \n* @param str La cha\u00eene recherch\u00e9e\n* @param pos (facultatif) La position \u00e0 partir de laquelle str est recherch\u00e9e\n* @return int La position du premier caract\u00e8re de la premi\u00e8re occurence de str dans la cha\u00eene. Si aucune occurence n'est trouv\u00e9e, renvoie string::npos.\n*/\nint string::find(string str, int pos);\n\n/**\n* @brief Remplace len caract\u00e8res \u00e0 partir de la position pos par la cha\u00eene s.\n* \n* @param pos La position \u00e0 partir de laquelle le rmeplacement commence.\n* @param len Le nombre de caract\u00e8res \u00e0 remplacer.\n* @param s La ch\u00e2ine \u00e0 ins\u00e9rer \u00e0 la place des caract\u00e8res \u00e0 remplacer.\n* @return string* Un pointeur vers la cha\u00eene.\n*/\nstring * string::replace(int pos, int len, string s);\n</code></pre> </li> <li> <p>Utiliser la fonction <code>replaceAll()</code> pour remplacer toutes les occurences de <code>Corbeau</code> et <code>Renard</code> respectivement par <code>Rossignol</code> et <code>Kangourou</code>.</p> </li> <li> <p>Cr\u00e9er une fonction qui calcule et renvoie la longueur du plus long vers en utilisant seulement les m\u00e9thodes ci-dessus.</p> </li> <li> <p>Ins\u00e9rer votre signature en bas \u00e0 droite de la fable align\u00e9e sur le vers le plus long en utilisant seulement la fonction que vous avez cr\u00e9\u00e9e et les surd\u00e9finitions suivantes de la m\u00e9thode <code>string::append()</code> :</p> <pre><code>/**\n* @brief Allonge la cha\u00eene en ajoutant n fois le caract\u00e8re c \u00e0 la fin de celle-ci. \n* \n* @param n Le nombre d'occurences de c attendues\n* @param c Le caract\u00e8re \u00e0 ajouter.\n* @return string* Un pointeur vers la cha\u00eene.\n*/\nstring * string::append(int n, char c);\n\n/**\n* @brief Allonge la cha\u00eene en ajoutant s \u00e0 la fin de celle-ci.\n* \n* @param s La chaine \u00e0 ajouter.\n* @return string* Un pointeur vers la cha\u00eene.\n*/\nstring * string::append(string s);\n</code></pre> </li> <li> <p>Tester votre code sur une autre fable.</p> </li> </ol> <p>R\u00e9sultat final :</p> <p></p> <pre><code>&gt; ./fable.exe\nMa\u00eetre Rossignol, sur un arbre perch\u00e9,\nTenait en son bec un fromage.\nMa\u00eetre Kangourou, par l'odeur all\u00e9ch\u00e9,\nLui tint \u00e0 peu pr\u00e8s ce langage :\nEt bonjour, Monsieur du Rossignol.\nQue vous \u00eates joli ! que vous me semblez beau !\nSans mentir, si votre ramage\nSe rapporte \u00e0 votre plumage,\nVous \u00eates le Ph\u00e9nix des h\u00f4tes de ces bois.\n\u00c0 ces mots, le Rossignol ne se sent pas de joie ;\nEt pour montrer sa belle voix,\nIl ouvre un large bec, laisse tomber sa proie.\nLe Kangourou s'en saisit, et dit : Mon bon Monsieur,\nApprenez que tout flatteur\nVit aux d\u00e9pens de celui qui l'\u00e9coute.\nCette le\u00e7on vaut bien un fromage, sans doute.\nLe Rossignol honteux et confus\nJura, mais un peu tard, qu'on ne l'y prendrait plus.\n\n                                       Mathieu DOMER\n</code></pre> Solution <p>Solution des questions 1 \u00e0 3 :</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n/**\n* @brief Remplace dans str toutes les occurences de search par replace.\n* \n* @param str La cha\u00eene d'origine\n* @param search La cha\u00eene recherch\u00e9e\n* @param replace La cha\u00eene de remplacement\n*/\nvoid replaceAll(string &amp; str, string search, string replace) {\n    int pos = str.find(search, 0);\n    while (pos != string::npos) {\n        str.replace(pos, search.length(), replace);\n        pos = str.find(search, 0);\n    }\n}\n\nint main() {\n\n    system(\"chcp 65001\");\n    system(\"cls\");\n\n    string fable =  \"Ma\u00eetre Corbeau, sur un arbre perch\u00e9,\\n\"\n                    \"Tenait en son bec un fromage.\\n\"\n                    \"Ma\u00eetre Renard, par l'odeur all\u00e9ch\u00e9,\\n\"\n                    \"Lui tint \u00e0 peu pr\u00e8s ce langage :\\n\"\n                    \"Et bonjour, Monsieur du Corbeau.\\n\"\n                    \"Que vous \u00eates joli ! que vous me semblez beau !\\n\"\n                    \"Sans mentir, si votre ramage\\n\"\n                    \"Se rapporte \u00e0 votre plumage,\\n\"\n                    \"Vous \u00eates le Ph\u00e9nix des h\u00f4tes de ces bois.\\n\"\n                    \"\u00c0 ces mots, le Corbeau ne se sent pas de joie ;\\n\"\n                    \"Et pour montrer sa belle voix,\\n\"\n                    \"Il ouvre un large bec, laisse tomber sa proie.\\n\"\n                    \"Le Renard s'en saisit, et dit : Mon bon Monsieur,\\n\"\n                    \"Apprenez que tout flatteur\\n\"\n                    \"Vit aux d\u00e9pens de celui qui l'\u00e9coute.\\n\"\n                    \"Cette le\u00e7on vaut bien un fromage, sans doute.\\n\"\n                    \"Le Corbeau honteux et confus\\n\"\n                    \"Jura, mais un peu tard, qu'on ne l'y prendrait plus.\\n\\n\";\n\n    cout &lt;&lt; fable;\n\n    replaceAll(fable, \"Corbeau\", \"Rossignol\");\n    replaceAll(fable, \"Renard\", \"Kangourou\");\n\n    cout &lt;&lt; fable;\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/30-poo-2/#lexercice-en-plus-en-plus","title":"L'exercice en plus en plus","text":"<p>On souhaite coder un programme permettant de simuler une partie de bataille.</p> <p>Pour cela, il faut cr\u00e9er un jeu de cartes, le m\u00e9langer, les distribuer \u00e0 deux joueurs et pouvoir les comparer.</p> <p>On d\u00e9cide de cr\u00e9er la classe <code>Card</code> dont le diagramme de classe est la suivant :</p> <p></p> <p>Description de la classe :</p> <ul> <li> <p>L'attribut <code>name</code> contiendra le nom de la carte qui doit figurer dans la liste suivante : <code>\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\"</code>;</p> </li> <li> <p>L'attribut <code>valeur</code>, qui permet de comparer les cartes, correspond \u00e0 l'indice du <code>name</code> dans la liste pr\u00e9c\u00e9dente (ex : un 7 \u00e0 une valeur de 5);</p> </li> <li> <p>L'attribut <code>couleur</code> contiendra la couleur de la carte qui doit figurer dans la liste suivante : <code>\"\u2665\", \"\u2660\", \"\u2666\", \"\u2663\"</code>;</p> </li> <li> <p>Le constructeur s'assure que les valeurs de nom et de couleur fournis respectent les r\u00e8gles ci-dessus et d\u00e9duit la valeur de la carte. En cas d'erreur concernant le nom ou la couleur, une exception invalid_argument doit \u00eatre lev\u00e9e;</p> </li> <li> <p>La m\u00e9thode <code>find()</code> doit renvoyer l'indice du premier param\u00e8tre dans le second ou -1 s'il n'y est pas pr\u00e9sent;</p> </li> <li> <p>La m\u00e9thode <code>toString()</code> renvoie une cha\u00eene de caract\u00e8re au format <code>[{color} {name}]</code> (ex : <code>[\u2660 Q]</code> pour la dame de pique);</p> </li> <li> <p>La m\u00e9thode <code>compareTo()</code> \u00e0 la mani\u00e8re de <code>strcmp()</code> renvoie :</p> <ul> <li> <p>0 si les deux cartes ont la m\u00eame valeur,</p> </li> <li> <p>-1 si la carte est de valeur inf\u00e9rieure \u00e0 celle pass\u00e9e en param\u00e8tre,</p> </li> <li> <p>1 si la carte est de valeur sup\u00e9rieure \u00e0 celle pass\u00e9e en param\u00e8tre.</p> </li> </ul> </li> </ul> <p>Les listes de couleurs et de noms doivent \u00eatre d\u00e9clar\u00e9es en tant qu'attribut statique, constant et public de la classe <code>Card</code>.</p> <ol> <li> <p>D\u00e9velopper la classe Card et la tester en instanciant une dame de pique et un as de c\u0153ur, en les comparant et en les affichant.</p> </li> <li> <p>Coder le programme principal permettant de simuler la partie de bataille :</p> <ol> <li> <p>Cr\u00e9ation des 52 cartes</p> </li> <li> <p>M\u00e9lange du paquet</p> <p>On pourra utiliser le code suivant :</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;random&gt;\n\n...\nvector&lt;Card&gt; deck;\n\n// Initialisation de la g\u00e9n\u00e9ration pseudo-al\u00e9atoire\ndefault_random_engine dre(time(NULL));\n// M\u00e9lange du vecteur deck\nshuffle(deck.begin(), deck.end(), dre);\n</code></pre> </li> <li> <p>Distribution des cartes en utilisant la classe <code>deque</code> qui permet de g\u00e9rer une pile ou une file.</p> </li> <li> <p>Partie de bataille.</p> <p>\u26a0\ufe0f Il faut un tas de carte pour le joueur 1, pour le joueur 2 et la table.</p> <p>\u26a0\ufe0f Il faut \u00eatre rigoureux avec les entr\u00e9es/sorties des cartes dans les tas ! </p> <p>\u26a0\ufe0f En fonction de l'impl\u00e9mentation, certains m\u00e9langes cr\u00e9ent des parties infinies ! Il faut trouver une parade en ajoutant un soup\u00e7on d'al\u00e9a !</p> </li> </ol> </li> </ol> Solution <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;deque&gt;\n#include &lt;stdexcept&gt;\n#include &lt;algorithm&gt;\n#include &lt;random&gt;\n\nusing namespace std;\n\nclass Card {\n    private:\n        string name;\n        string color;\n        int value;\n        int find(string needle, vector&lt;string&gt; haystack) {\n            for (int i = 0; i &lt; haystack.size(); i++) {\n                if (needle == haystack[i]) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    public:\n        const static vector&lt;string&gt; names;\n        const static vector&lt;string&gt; colors;\n        Card(string _name, string _color) {\n            value = find(_name, names);\n            if (value == -1) {\n                throw invalid_argument(\"Unauthorized name : \" + _name);\n            }\n            name = _name;\n            if (find(_color, colors) == -1) {\n                throw invalid_argument(\"Unauthorized color : \" + _color);\n            }\n            color = _color;\n        }\n        string toString() {\n            return \"[\" + color + (name == \"10\" ? \"\": \" \") + name + \"]\";\n        }\n        int compareTo(Card _c) {\n            if (value == _c.value) {\n                return 0;\n            }\n            if (value &lt; _c.value) {\n                return -1;\n            }\n            return 1;\n        }\n        string getColor() {return color;}\n};\n\nconst vector&lt;string&gt; Card::names = { \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\" };\n\nconst vector&lt;string&gt; Card::colors = { \"\u2665\", \"\u2660\", \"\u2666\", \"\u2663\" };\n\nint main() {\n    system(\"chcp 65001\");\n    system(\"cls\");\n\n    vector&lt;Card&gt; deck; \n    deque&lt;Card&gt; p1, p2, table;\n    int i;\n\n    // Constitution du paquet de cards\n    for (i = 0; i &lt; Card::colors.size(); i++) {\n        for (int j = 0; j &lt; Card::names.size(); j++) {\n            deck.push_back(Card(Card::names[j], Card::colors[i]));\n        }\n    }\n\n    // M\u00e9lange du paquet\n    default_random_engine dre(time(NULL));\n    shuffle(deck.begin(), deck.end(), dre);\n\n    // Distribution des cartes\n    for (i = 0; i &lt; deck.size(); i++) {\n        if (i % 2 == 0) {\n            p1.push_front(deck[i]);\n        }\n        else {\n            p2.push_front(deck[i]);\n        }\n    }\n\n    // Jeu\n    for (i = 0; !p1.empty() &amp;&amp; !p2.empty(); i++) {\n\n        cout &lt;&lt; endl &lt;&lt; i &lt;&lt;  \": P1 : \" &lt;&lt; p1.size() &lt;&lt; \" / P2 : \" &lt;&lt; p2.size() &lt;&lt; endl;\n\n        // Chaque joueur pose une carte\n        table.push_front(p2.front());\n        p2.pop_front();\n        table.push_front(p1.front());\n        p1.pop_front();\n\n        cout &lt;&lt; table[0].toString() &lt;&lt; \" x \" &lt;&lt; table[1].toString() &lt;&lt; endl;\n\n        // Comparaison des cartes\n        switch(table[0].compareTo(table[1])) {\n            // Bataille\n            case 0 :\n                cout &lt;&lt; \"Bataille !\" &lt;&lt; endl;\n                if (!p1.empty() &gt; 0 &amp;&amp; !p2.empty()) {\n                    // Chaque joueur pose une carte\n                    table.push_front(p2.front());\n                    p2.pop_front();\n                    table.push_front(p1.front());\n                    p1.pop_front();\n                    // et on rejoue...\n                }\n                break;\n            // P1 gagne\n            case 1 :\n                cout &lt;&lt; \"P1 gagne !\" &lt;&lt; endl;\n                // P1 empoche les cartes de la table\n                shuffle(table.begin(), table.end(), dre);\n                while (!table.empty()) {\n                    p1.push_back(table.front());\n                    table.pop_front();\n                }\n                break;\n            // P2 gagne\n            case -1 :\n                cout &lt;&lt; \"P2 gagne !\" &lt;&lt; endl;\n                // P2 empoche les cartes de la table\n                shuffle(table.begin(), table.end(), dre);\n                while (!table.empty()) {\n                    p2.push_back(table.front());\n                    table.pop_front();\n                }\n                break;\n        }\n    }\n\n    cout &lt;&lt; (p1.empty() ? \"P2\" : \"P1\") &lt;&lt; \" gagne la partie en \" &lt;&lt; i &lt;&lt; \" coups !\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/40-poo-3/","title":"04 - POO ++","text":""},{"location":"bts-2/40-poo-3/#constructeur-par-recopie","title":"Constructeur par recopie","text":""},{"location":"bts-2/40-poo-3/#exercice-0","title":"Exercice 0","text":"<p>Compl\u00e9ter la classe <code>Tab</code> suivante permettant de g\u00e9rer un tableau d\u2019entiers en allocation dynamique et pr\u00e9sentant un bug lors de son utilisation  dans le fichier exo.cpp \u00e0 la ligne 17.</p> <pre><code>// Tab.h\n#ifndef TAB_H\n#define TAB_H\nclass Tab {\n    private :\n        int count;\n        int * first;\n    public :\n        Tab(int);\n        ~Tab();\n        void insert(int, int);\n        int get(int);\n        void display();\n};\n#endif\n</code></pre> <pre><code>// Tab.cpp\n#include \"Tab.h\"\n#include &lt;iostream&gt;\n\nTab::Tab(int _count) {\n    count = _count;\n    first = new int[count]{0};\n}\n\nTab::~Tab() {\n    delete [] first;\n}\n\nvoid Tab::insert(int i, int value) {\n    if (i &gt;= 0 &amp;&amp; i &lt; count) {\n        first[i] = value;\n    }\n}\n\nint Tab::get(int i) {\n    if (i &gt;= 0 &amp;&amp; i &lt; count) {\n        return first[i];\n    }\n    throw \"Indice hors-limite !\";\n}\n\nvoid Tab::display(){\n    std::cout &lt;&lt; \"[ \";\n    for (int i = 0; i &lt; count; i++) {\n        std::cout &lt;&lt; first[i] &lt;&lt; (i &lt; count - 1 ? \", \" : \"\" );\n    }\n    std::cout &lt;&lt; \" ]\\n\";\n}\n</code></pre> <pre><code>// exo0.cpp\n#include \"Tab.h\"\n\nint main() {\n    Tab t1(10);\n\n    t1.display();\n    t1.insert(3, 45);\n    t1.insert(7, -89053);\n    t1.display();\n    std::cout &lt;&lt; \"t1[3] : \" &lt;&lt; t1.get(3) &lt;&lt; std::endl;\n\n    Tab t2 = t1;\n    t2.display();\n    t2.insert(6, 78);\n    t2.display();\n    t1.display(); // \ud83d\ude31\n\n    return 0;\n}\n</code></pre> Solution <pre><code>// Tab.h\n#ifndef TAB_H\n#define TAB_H\nclass Tab {\n    private :\n        int count;\n        int * first;\n    public :\n        Tab(int);\n        Tab(Tab &amp;); // &lt;- D\u00e9claration du constructeur par recopie\n        ~Tab();\n        void insert(int, int);\n        int get(int);\n        void display();\n};\n#endif\n</code></pre> <p>Ajouter dans 'Tab.cpp' :</p> <pre><code>// D\u00e9finition du constructeur par recopie\nTab::Tab(Tab &amp; t) {\n    count = t.count;\n    first = new int[count]{0};\n    for (int i = 0; i &lt; count; i++) {\n        first[i] = t.first[i];\n    }\n}\n</code></pre>"},{"location":"bts-2/40-poo-3/#exercice-1","title":"Exercice 1","text":"<p>Soit le programme suivant :</p> <pre><code>#include \"Truc.h\"\n\nvoid fonction (Truc a) {\n    // Ne se passe-t-il vraiment rien ici \ud83e\udd14\n}\n\nint main() {\n    Truc x;\n    Truc y = x;\n    fonction(y);\n    cout &lt;&lt; \"Bonjour !\" &lt;&lt; endl;\n}\n</code></pre> <p>Cr\u00e9er la classe <code>Truc</code> de mani\u00e8re \u00e0 ce que le programme ci-dessus fournisse le r\u00e9sultat suivant :</p> <pre><code>&gt; ./exo1.exe\nCr\u00e9ation d'un truc\nCopie d'un truc\nCopie d'un truc\nDestruction d'un truc\nBonjour !\nDestruction d'un truc\nDestruction d'un truc\n</code></pre> Solution <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Truc {\n    public:\n        Truc() {\n            cout &lt;&lt; \"Cr\u00e9ation d'un truc\" &lt;&lt; endl;\n        }\n        Truc(Truc &amp; t) {\n            cout &lt;&lt; \"Copie d'un truc\" &lt;&lt; endl;\n        }\n        ~Truc() {\n            cout &lt;&lt; \"Destruction d'un truc\" &lt;&lt; endl;\n        }\n};\n</code></pre> <p>On passe deux fois dans le constructeur par recopie :</p> <ul> <li> <p>\u00e0 l'initialisation de y avec x</p> </li> <li> <p>lors de la recopie de y dans a quand on appelle fonction(y)</p> </li> </ul>"},{"location":"bts-2/40-poo-3/#exercice-2","title":"Exercice 2","text":"<p>A faire sur papier !</p> <p>Que va afficher le programme suivant ?</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Point {\n    private:\n        int x, y;\n    public:\n        Point(int abs = 1, int ord = 0) {\n            x = abs;\n            y = ord;\n            cout &lt;&lt; \"C : \" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; endl;\n        };\n        Point(Point &amp;);\n        ~Point();\n};\n\nPoint::Point(Point &amp; d) {\n    cout &lt;&lt; \"R : \" &lt;&lt; d.x &lt;&lt; \", \" &lt;&lt; d.y &lt;&lt; endl;\n    x = d.x;\n    y = d.y;\n}\n\nPoint::~Point() {\n    cout &lt;&lt; \"D !\"&lt;&lt; endl;\n}\n\nvoid fct (Point, Point *);\n\nint main() {\n    cout &lt;&lt; \"D\u00e9but main\" &lt;&lt; endl;\n    Point a;\n    Point c = a;\n    Point *adr = new Point (3, 3);\n    fct(a, adr);\n    c = Point(5, 5);\n    cout &lt;&lt; \"Fin main\" &lt;&lt; endl;\n}\n\nvoid fct (Point d, Point * add) {\n    cout &lt;&lt; \"Entr\u00e9e fct\" &lt;&lt; endl;\n    delete add;\n    cout &lt;&lt; \"Sortie fct\" &lt;&lt; endl;\n}\n</code></pre> Solution <pre><code>D\u00e9but main\nC : 1, 0    // (1)!\nR : 1, 0    // (2)!\nC : 3, 3    // (3)!\nR : 1, 0    // (4)!\nEntr\u00e9e fct\nD !         // (5)!\nSortie fct\nD !         // (6)!\nC : 5, 5    // (7)!\nD !         // (8)!\nFin main\nD !         // (9)!\nD !         // (10)!\n</code></pre> <ol> <li>Cr\u00e9ation de a</li> <li>Recopie de a dans c</li> <li>Cr\u00e9ation du point dans le tas</li> <li>Recopie de a dans le param\u00e8tre d (passage par valeur)</li> <li>Destruction du point cr\u00e9\u00e9 dans le tas</li> <li>Destruction de d</li> <li>Cr\u00e9ation du point \u00e9ph\u00e9m\u00e8re avant affectation dans c</li> <li>Destruction du point \u00e9ph\u00e9m\u00e8re</li> <li>Destruction de c</li> <li>Destruction de a</li> </ol>"},{"location":"bts-2/40-poo-3/#surdefinition-doperateur","title":"Surd\u00e9finition d'op\u00e9rateur","text":""},{"location":"bts-2/40-poo-3/#exercice-3","title":"Exercice 3","text":"<p>Soit une classe Vecteur3d :</p> <pre><code>class Vecteur3d {\n    private:\n        float x, y, z;\n    public:\n        Vecteur3d (int _x = 0, int _y = 0, int _z = 0) {\n            x = _x;\n            y = _y;\n            z = _z;\n        }\n};\n</code></pre> <ol> <li> <p>Surd\u00e9finir l'op\u00e9rateur == en utilisant une fonction membre inline.</p> <p>Deux <code>Vecteur3D</code> sont \u00e9gaux si leurs coordonn\u00e9es sont respectivement \u00e9gales.</p> </li> <li> <p>Surd\u00e9finir l'op\u00e9rateur != en utilisant une fonction membre inline.</p> <p>Trouver un moyen \"malin\" ne pas utiliser les attributs x, y, z pour la surcharge de l'op\u00e9rateur !=.</p> </li> <li> <p>Cr\u00e9er un programme de test.</p> </li> </ol> Solution <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Vecteur3d {\n    private:\n        float x, y, z;\n    public:\n        Vecteur3d (int _x = 0, int _y = 0, int _z = 0) {\n            x = _x;\n            y = _y;\n            z = _z;\n        }\n        bool operator == (Vecteur3d &amp;);\n        bool operator != (Vecteur3d &amp;);\n};\n\n// Les fonctions inline doivent \u00eatre dans le m\u00eame fichier que la d\u00e9claration de la classe\n\ninline bool Vecteur3d::operator == (Vecteur3d &amp; v) {\n    return (x == v.x &amp;&amp; y == v.y &amp;&amp; z == v.z);\n}\n\ninline bool Vecteur3d::operator != (Vecteur3d &amp; v) {\n    return (!(*this == v));\n}\n\nint main() {\n\n    Vecteur3d a, b, c(1, 2, 3);\n\n    if (a == b) {\n        cout &lt;&lt; \"a == b\" &lt;&lt; endl;\n    }\n\n    if (a == c) {\n        cout &lt;&lt; \"On ne doit pas passer ici !\" &lt;&lt; endl;\n    }\n\n    if (a != b) {\n        cout &lt;&lt; \"Ni l\u00e0 !\" &lt;&lt; endl;\n    }\n\n    if (a != c) {\n        cout &lt;&lt; \"a != c\" &lt;&lt; endl;\n    }\n\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/40-poo-3/#exercice-4","title":"Exercice 4","text":"<p>Reprendre la classe <code>Tab</code> de l\u2019exercice 0.</p> <ol> <li> <p>Surd\u00e9finir l'op\u00e9rateur <code>=</code> pour que l'affectation soit possible entre deux objets <code>Tab</code>.</p> <pre><code>Tab t1(10), t2(5);\nt2 = t1;\n</code></pre> </li> <li> <p>Surd\u00e9finir l'op\u00e9rateur <code>[ ]</code> pour affecter et r\u00e9cup\u00e9rer des valeurs directement dans le tableau sans passer par <code>set</code> ou <code>get</code>.  Ne pas oublier d'indiquer un d\u00e9bordement d'indice du tableau.  Dans ce cas, on lancera une exception.</p> <pre><code>Tab t1(10);\nt1[5] = 7;\ncout &lt;&lt; t1[3];\n</code></pre> Un peu d\u2019aide ? <p>https://en.cppreference.com/w/cpp/language/operators#Array_subscript_operator</p> </li> <li> <p>Surd\u00e9finir l\u2019op\u00e9rateur <code>+</code> pour concat\u00e9ner des tableaux.</p> </li> <li> <p>Trouver un moyen d\u2019afficher un tableau au complet \u00e0 l\u2019aide de <code>cout</code>.</p> <pre><code>Tableau t1(10);\nt1[5] = 7;\ncout &lt;&lt; t1;\n</code></pre> </li> </ol> Solution <pre><code>// Tab.h\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n#ifndef TAB_H\n#define TAB_H\nclass Tab {\n    private :\n        int count;\n        int * first;\n    public :\n        Tab(int);\n        Tab(Tab &amp;);\n        ~Tab();\n        Tab &amp; operator = (Tab);\n        int &amp; operator [] (int);\n        Tab operator + (Tab &amp;);\n        // Fonction \"amie\" d\u00e9finie \u00e0 l'ext\u00e9rieur de la classe ostream, \n        // mais qui aura acc\u00e8s \u00e0 tous les attributs de la classe.\n        friend ostream &amp; operator &lt;&lt; (ostream &amp;, Tab &amp;);\n};\n#endif\n</code></pre> <pre><code>// Tab.cpp\n#include \"Tab.h\"\n\nTab::Tab(int _count) {\n    count = _count;\n    first = new int[count]{0};\n}\n\nTab::Tab(Tab &amp; t) {\n    count = t.count;\n    first = new int[count]{0};\n    for (int i = 0; i &lt; count; i++) {\n        first[i] = t.first[i];\n    }\n}\n\nTab::~Tab() {\n    delete [] first;\n}\n\nTab &amp; Tab::operator = (Tab t) {\n    count = t.count;\n    // On n'oublie pas d'effacer l'ancien tableau\n    delete [] first;\n    first = new int[count]{0};\n    for (int i = 0; i &lt; count; i++) {\n        first[i] = t.first[i];\n    }\n    return *this;\n}\n\nint &amp; Tab::operator [] (int i) {\n    if (i &gt; count) {\n        throw \"Indice hors-limite !\"; // On lance une exception pour interrompre le programme.\n    }\n    return first[i];\n}\n\nTab Tab::operator + (Tab &amp; t) {\n    // Nouveau tableau \n    Tab tNew(count + t.count);\n    // Remplissage de la premi\u00e8re partie avec les valeurs de l'objet courant\n    for (int i = 0; i &lt; count; i++) {\n        tNew.first[i] = first[i];\n    }\n    // Remplissage de la deuxi\u00e8me partie avec les valeurs de l'objet en param\u00e8tre\n    for (int i = 0; i &lt; t.count; i++) {\n        tNew.first[i + count] = t.first[i];\n    }\n    // On renvoie le nouveau tableau\n    return tNew;\n}\n\n// Fonction amie donc juste operator et non Tab::operator\nostream &amp; operator &lt;&lt; (ostream &amp; os, Tab &amp; t) {\n    os &lt;&lt; \"[ \";\n    for (int i = 0; i &lt; t.count; i++) {\n        os &lt;&lt; t.first[i] &lt;&lt; (i &lt; t.count - 1 ? \", \" : \"\" );\n    }\n    os &lt;&lt; \" ]\\n\";\n    return os;\n}\n</code></pre> <pre><code>// exo4.cpp\n#include \"Tab.h\"\n\nint main() {\n    Tab t1(10), t2(5), t3(1);\n\n    cout &lt;&lt; t2;             // Surd\u00e9finition de l'op\u00e9rateur &lt;&lt; de ostream\n    t2 = t1;                // Surd\u00e9finition de l'op\u00e9rateur =\n    cout &lt;&lt; t2;             // Surd\u00e9finition de l'op\u00e9rateur &lt;&lt; de ostream\n\n    cout &lt;&lt; t1;             // Surd\u00e9finition de l'op\u00e9rateur &lt;&lt; de ostream\n    t1[5] = 7;              // Surd\u00e9finition de l'op\u00e9rateur [ ]\n    cout &lt;&lt; t1[5] &lt;&lt; endl;  // Surd\u00e9finition de l'op\u00e9rateur [ ]\n    cout &lt;&lt; t1;             // Surd\u00e9finition de l'op\u00e9rateur &lt;&lt; de ostream\n\n    cout &lt;&lt; t3;             // Surd\u00e9finition de l'op\u00e9rateur &lt;&lt; de ostream\n    t2[3] = 42;             // Surd\u00e9finition de l'op\u00e9rateur [ ]\n    t3 = t1 + t2;           // Surd\u00e9finition de l'op\u00e9rateur + et =\n    cout &lt;&lt; t3;             // Surd\u00e9finition de l'op\u00e9rateur &lt;&lt; de ostream\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/40-poo-3/#lexercice-en-plus","title":"L'exercice en plus","text":"<p>En utilisant la classe Card (issue de l'exercice en plus en plus du chapitre pr\u00e9c\u00e9dent), surd\u00e9finir les op\u00e9rateurs suivants :</p> <ul> <li> <p>op\u00e9rateur + : l'addition de deux cartes renverra un entier, somme des valeurs des 2 cartes.</p> </li> <li> <p>op\u00e9rateur == : deux cartes sont \u00e9gales si elles ont la m\u00eame valeur</p> </li> <li> <p>op\u00e9rateur &gt; : une carte est sup\u00e9rieure \u00e0 une autre si sa valeur est strictement sup\u00e9rieure</p> </li> <li> <p>op\u00e9rateur &lt; : une carte est inf\u00e9rieure \u00e0 une autre si sa valeur est strictement inf\u00e9rieure</p> </li> <li> <p>op\u00e9rateur + des entiers : additionner un entier avec une carte, additionne l'entier avec la valeur de la carte :</p> <ul> <li>On pourra tester avec l'addition suivante : Card(\"\u2665\", \"2\") + Card(\"\u2665\", \"3\") + Card(\"\u2665\", \"4\") qui doit renvoyer 9</li> </ul> </li> </ul> <p>Ecrire un programme de test.</p> <p>Cr\u00e9er un jeu de bataille ou de blackjack (cr\u00e9ation d'un paquet et m\u00e9lange dans la solution de cet exercice.).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;deque&gt;\n#include &lt;stdexcept&gt;\n#include &lt;algorithm&gt;\n#include &lt;random&gt;\n\nusing namespace std;\n\nclass Card {\n    private:\n        string name;\n        string color;\n        int value;\n        int find(string needle, vector&lt;string&gt; haystack) {\n            for (int i = 0; i &lt; haystack.size(); i++) {\n                if (needle == haystack[i]) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    public:\n        const static vector&lt;string&gt; names;\n        const static vector&lt;string&gt; colors;\n        Card(string _name, string _color) {\n            value = find(_name, names);\n            if (value == -1) {\n                throw invalid_argument(\"Unauthorized name : \" + _name);\n            }\n            value += 2;\n            name = _name;\n            if (find(_color, colors) == -1) {\n                throw invalid_argument(\"Unauthorized color : \" + _color);\n            }\n            color = _color;\n        }\n        friend ostream &amp; operator &lt;&lt; (ostream &amp; os, Card c) {\n            return os &lt;&lt; \"[\" + c.color + (c.name == \"10\" ? \"\": \" \") + c.name + \"]\";\n        }\n};\n\nconst vector&lt;string&gt; Card::names = { \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\" };\n\nconst vector&lt;string&gt; Card::colors = { \"\u2665\", \"\u2660\", \"\u2666\", \"\u2663\" };\n</code></pre>"},{"location":"bts-2/40-poo-3/#heritage","title":"H\u00e9ritage","text":""},{"location":"bts-2/40-poo-3/#exercice-5","title":"Exercice 5","text":""},{"location":"bts-2/40-poo-3/#partie-1","title":"Partie 1","text":"<p>Ecrire une classe Batiment avec les attributs suivants :</p> <pre><code>string adresse;\n</code></pre> <p>La classe Batiment doit disposer des constructeurs suivants:</p> <pre><code>Batiment();\nBatiment (adresse);\n</code></pre> <p>La classe B\u00e2timent doit contenir les accesseurs et mutateurs pour ses attributs.</p>"},{"location":"bts-2/40-poo-3/#partie-2","title":"Partie 2","text":"<p>Ecrire une classe Maison h\u00e9ritant de Batiment avec les attributs suivants:</p> <pre><code>int NbPieces; // Le nombre de pi\u00e8ces de la maison\n</code></pre> <p>La classe Maison doit disposer des constructeurs suivants:</p> <pre><code>Maison();\nMaison(adresse, nbPieces);\n</code></pre> <p>La classe Maison doit contenir des accesseurs pour ses attributs.</p>"},{"location":"bts-2/40-poo-3/#partie-3","title":"Partie 3","text":"<p>Ecrire un programme afin de tester ces deux classes avec le debugger.</p> Solution <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n// Partie 1\nclass Batiment {\n    private :\n        string adresse;\n    public :\n        Batiment() {\n            adresse = \"Sans adresse\";\n        };\n        Batiment (string _adresse) {\n            adresse = _adresse;\n        };\n        string getAdresse(){\n            return adresse;\n        };\n        void setAdresse(string _adresse) {\n            adresse = _adresse;\n        };\n};\n\n// Partie 2\nclass Maison : public Batiment {\n    private :\n        int nbPieces;\n    public :\n        Maison() {\n            nbPieces = 0;\n        };\n        Maison(string _adresse, int _nbPieces) : Batiment(_adresse) {\n            nbPieces = _nbPieces;\n        };\n        int getNbPieces() {\n            return nbPieces;\n        };\n        void setNbPieces(int _nbPieces) {\n            nbPieces = _nbPieces;\n        };\n};\n\n// Partie 3\nint main() {\n    Batiment b1, b2(\"15 rue Crossadiere 53000 LAVAL\");\n    Maison m1, m2(\"12 rue de la paix 75001 PARIS\", 9);\n\n    cout &lt;&lt; \"b1 : \" &lt;&lt; b1.getAdresse() &lt;&lt; endl;\n    cout &lt;&lt; \"m1 : \" &lt;&lt; m1.getAdresse() &lt;&lt; \" \" &lt;&lt; m1.getNbPieces() &lt;&lt; endl;\n\n    b1.setAdresse(\"165 avenue du General de Gaulle 49100 ANGERS\");\n    m1.setAdresse(\"Lieu-dit la Girandieres 44300 NANTES\");\n    m1.setNbPieces(6);\n\n    cout &lt;&lt; \"b1 : \" &lt;&lt; b1.getAdresse() &lt;&lt; endl;\n    cout &lt;&lt; \"m1 : \" &lt;&lt; m1.getAdresse() &lt;&lt; \" \" &lt;&lt; m1.getNbPieces() &lt;&lt; endl;\n\n    cout &lt;&lt; \"b2 : \" &lt;&lt; b2.getAdresse() &lt;&lt; endl;\n    cout &lt;&lt; \"m2 : \" &lt;&lt; m2.getAdresse() &lt;&lt; \" \" &lt;&lt; m2.getNbPieces() &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"bts-2/40-poo-3/#exercice-6","title":"Exercice 6","text":""},{"location":"bts-2/40-poo-3/#presentation","title":"Pr\u00e9sentation","text":"<p>On veut g\u00e9rer les \u00e9tudiants d\u2019une \u00e9cole \u00e0 l\u2019aide d\u2019une classe <code>Etudiant</code> d\u00e9finie par les attributs suivants :</p> <ul> <li> <p><code>nom</code> : nom d\u2019un \u00e9tudiant</p> </li> <li> <p><code>pr\u00e9nom</code> : pr\u00e9nom d\u2019un \u00e9tudiant</p> </li> <li> <p><code>notes</code> : tableau contenant les notes d\u2019un \u00e9tudiant</p> </li> </ul> <p>Constructeur, destructeur, accesseurs et mutateurs et les m\u00e9thodes suivantes :</p> <ul> <li> <p><code>void affichage()</code>, permettant l\u2019affichage d\u2019un \u00e9tudiant</p> </li> <li> <p><code>float moyenne()</code>, retourne comme r\u00e9sultat la moyenne des notes d\u2019un \u00e9tudiant.</p> </li> </ul> <p>On veut \u00e9galement repr\u00e9senter, \u00e0 l\u2019aide d\u2019une nouvelle classe Etudiant2A, certains \u00e9tudiants qui poss\u00e8dent un attribut suppl\u00e9mentaire :</p> <ul> <li><code>note_stage</code>, qui repr\u00e9sente la note de leur stage.</li> </ul> <p>Les m\u00e9thodes \u00e0 associer \u00e0 cette classe sont les suivantes :</p> <ul> <li> <p><code>void affichage()</code>, permettant l\u2019affichage d\u2019un \u00e9tudiant 2\u00e8me ann\u00e9e</p> </li> <li> <p><code>float moyenne()</code>, retourne la moyenne finale (la moyenne des notes et la note de stage ont le m\u00eame poids).</p> </li> </ul>"},{"location":"bts-2/40-poo-3/#taches","title":"T\u00e2ches","text":"<ol> <li> <p>Donner la repr\u00e9sentation UML des deux classes dans Visual Paradigm.</p> </li> <li> <p>Ecrire la classe Etudiant en C++.</p> </li> <li> <p>Ecrire la classe Etudiant2A en C++.</p> </li> <li> <p>Ecrire un programme de test.</p> </li> </ol> Solution <p></p>"},{"location":"bts-2/80-battleships-1/","title":"BattleShips","text":"Brainstorming initial <p>Architecture</p> <ul> <li>Machine h\u00f4te-cliente</li> <li>Num\u00e9ro de port</li> <li>R\u00e9ponse aux actions des joueurs</li> <li>Possibilit\u00e9 d'arr\u00eater et reprendre une partie</li> <li>PC A -&gt; n\u00b0 de case (A7) -&gt; PC B</li> <li>PC B -&gt; \u00e9tat de la case (00 pas touch\u00e9, 10 touch\u00e9, 11 coul\u00e9) -&gt; PC A</li> </ul> <p>IHM</p> <ul> <li>Affichage des 2 plateaux</li> <li>Liste des bateaux \u00e0 \u00e9liminer et restant en jeu</li> <li>Les bateaux sont d\u00e9pla\u00e7ables tant qu'on n'a pas valid\u00e9 son plateau de jeu</li> <li>Placer un bateau permet de l'orienter</li> <li>Le placement se termine par une validation</li> </ul> <p>M\u00e9canismes de jeu</p> <ul> <li>Choix al\u00e9atoire du premier joueur</li> </ul>"},{"location":"bts-2/80-battleships-1/#cas-dutilisation-scenarios","title":"Cas d'utilisation / Sc\u00e9narios","text":"R\u00e9flexion collective <ul> <li> <p>Cr\u00e9er une partie</p> <ul> <li> <p>G\u00e9n\u00e9rer et communiquer un code</p> </li> <li> <p>Param\u00e9trer la partie</p> <ul> <li> <p>Taille du plateau</p> </li> <li> <p>Le nombre et la taille des bateaux</p> </li> <li> <p>Temps de jeu ?</p> </li> <li> <p>Rejouer si touche ?</p> </li> <li> <p>Attaque simultan\u00e9e ?</p> </li> </ul> </li> <li> <p>Attendre l'autre joueur</p> </li> </ul> </li> <li> <p>Rejoindre une partie</p> <ul> <li> <p>Renseigner un code</p> </li> <li> <p>Rejoindre une partie al\u00e9atoire ?</p> </li> <li> <p>Attendre l'autre joueur</p> </li> </ul> </li> <li> <p>Reprendre une partie</p> <ul> <li> <p>Renseigner un code</p> </li> <li> <p>Attendre l'autre joueur</p> </li> </ul> </li> <li> <p>Placer ses bateaux</p> <ul> <li> <p>Orienter les bateaux</p> </li> <li> <p>Valider le placement</p> </li> <li> <p>Optionnel ? minuteur (ex : 1'30\")</p> </li> <li> <p>Optionnel ? placement auto si d\u00e9lai d\u00e9pass\u00e9</p> </li> </ul> </li> <li> <p>Attaquer son adversaire</p> <ul> <li> <p>Pr\u00e9-requis : les deux joueurs ont termin\u00e9 la phase de placement</p> </li> <li> <p>Si premi\u00e8re attaque : tirage au sort</p> </li> <li> <p>Choisir une case</p> <ul> <li>V\u00e9rifier si attaquable</li> </ul> </li> <li> <p>Valider la case</p> </li> <li> <p>Visualiser l'attaque (animation)</p> </li> <li> <p>Optionnel : r\u00e9-attaquer si touche</p> </li> <li> <p>Optionnel ? minuteur (ex : 30\" pour attaquer, param\u00e9trable)</p> </li> </ul> </li> <li> <p>Terminer une partie</p> <ul> <li> <p>Gagner ou perdre</p> </li> <li> <p>Calculer un score</p> </li> </ul> </li> <li> <p>Consulter son profil</p> <ul> <li> <p>Choisir un nom de joueur</p> </li> <li> <p>Consulter son historique</p> </li> <li> <p>Calculer un rang</p> </li> <li> <p>Photo de profil</p> </li> <li> <p>Troph\u00e9es/succ\u00e8s ?</p> <ul> <li>Titres/Surnoms utilisables</li> </ul> </li> </ul> </li> </ul>"},{"location":"bts-2/80-battleships-1/#diagramme-des-cas-dutilisation","title":"Diagramme des cas d'utilisation","text":""},{"location":"bts-2/80-battleships-1/#scenarios","title":"Sc\u00e9narios","text":"<p>Info</p> <p>Chaque cas d'utilisation est d\u00e9taill\u00e9 sous la forme de sc\u00e9narios, on y distingue :</p> <ul> <li> <p>Le num\u00e9ro et le titre du cas d'utilisation</p> </li> <li> <p>Les pr\u00e9-requis \u00e0 l'ex\u00e9cution du cas d'utilisation</p> <p>Exemple : L'utilisateur est connect\u00e9</p> </li> <li> <p>Les acteurs impliqu\u00e9s</p> </li> <li> <p>Le d\u00e9roulement des sc\u00e9narios : la suite d'action \u00e0 r\u00e9aliser pour ex\u00e9cuter le sc\u00e9nario</p> <p>Exemple :</p> <ol> <li> <p>L'utilisateur lance le logiciel,</p> </li> <li> <p>L'utilisateur clique sur \"Nouveau document\",</p> </li> <li> <p>L'utilisateur saisit le texte d\u00e9sir\u00e9.</p> </li> </ol> <p>On distingue les sc\u00e9narios alternatifs et les cas d'erreur.</p> </li> </ul>"},{"location":"bts-2/90-qt-1/","title":"Qt","text":""},{"location":"bts-2/90-qt-1/#objectifs","title":"Objectifs","text":"<ul> <li>Installer Qt</li> <li>D\u00e9couvrir le framework Qt</li> <li>Se rep\u00e9rer dans le mod\u00e8le objets de Qt</li> <li>D\u00e9tecter et expliquer le m\u00e9canisme de signaux/slots de Qt</li> <li>Param\u00e9trer l\u2019environnement de d\u00e9veloppement Qt Creator</li> <li>Diff\u00e9rencier les contr\u00f4les disponibles dans Qt</li> </ul>"},{"location":"bts-2/90-qt-1/#travail","title":"Travail","text":""},{"location":"bts-2/90-qt-1/#mise-en-situation","title":"Mise en situation","text":"<p>Votre chef vous annonce que votre \u00e9quipe va devoir d\u00e9velopper une application multi-plateforme \u00e0 l'aide de l'environnement de d\u00e9veloppement Qt. Il ne le conna\u00eet pas et vous non plus \ud83d\ude35\u200d\ud83d\udcab. </p> <p>Pour se faire une id\u00e9e de la difficult\u00e9 de mise en oeuvre, puis chiffrer le d\u00e9veloppement, il vous demande d'\u00e9tudier le framework et de lui pr\u00e9parer un guide simple, imag\u00e9 et rapide \u00e0 lire du fonctionnement des applications Qt.</p>"},{"location":"bts-2/90-qt-1/#partie-1-installation","title":"Partie 1 - Installation","text":"<p>Installons ensemble Qt sur votre poste : https://www.qt.io/qt-educational-license#application</p> <p>A l'aide de copies d'\u00e9cran et de vos notes, r\u00e9diger un manuel d'installation de Qt.</p> <p>Testez-le en installant Qt sur votre poste \u00e0 la maison.</p>"},{"location":"bts-2/90-qt-1/#partie-2-etude-dune-application","title":"Partie 2 - Etude d'une application","text":"<p>Etudier en bin\u00f4me une application exemple QT parmi les deux applications suivantes : </p> <ul> <li> <p>Text Edit</p> </li> <li> <p>Calculator Form</p> </li> </ul> <p>En vous aidant de la documentation de l'application, de l'aide et de la documentation en ligne (https://doc.qt.io/) :</p> <ul> <li>Lancer l'application et la tester.</li> <li>Visiter l'environnement de d\u00e9veloppement</li> <li>D\u00e9tecter le point d'entr\u00e9e du programme.</li> <li>Trouver l'endroit o\u00f9 est con\u00e7ue l'IHM.<ul> <li>Tenter de d\u00e9placer un \u00e9l\u00e9ment/contr\u00f4le.</li> <li>Identifier/Lister les propri\u00e9t\u00e9s des \u00e9l\u00e9ments d'IHM. Que peut-on modifier ?</li> <li>Trouver la liste des \u00e9l\u00e9ments d'IHM disponibles</li> </ul> </li> <li>Identifier les m\u00e9thodes correspondant aux actions des contr\u00f4les.<ul> <li>Trouver o\u00f9 est le code correspondant \u00e0 l'activation d'un \u00e9l\u00e9ment.</li> <li>Comment l'\u00e9l\u00e9ment graphique et son code sont-ils li\u00e9s ?</li> </ul> </li> </ul>"},{"location":"bts-2/90-qt-1/#partie-2-synthese","title":"Partie 2 - Synth\u00e8se","text":""},{"location":"nsi/10_coder/","title":"Coder \u00e0 la maison","text":""},{"location":"nsi/10_coder/#solution-1-utiliser-un-ide-en-ligne","title":"Solution 1 : Utiliser un IDE en ligne","text":"<ul> <li> <p>Programmiz</p> <p>Pas de sauvegarde, pour tester rapidement</p> <pre><code>https://www.programiz.com/python-programming/online-compiler/\n</code></pre> </li> <li> <p>OnlineGDB</p> <p>N\u00e9cessit\u00e9 de cr\u00e9er un compte pour sauvegarder en ligne</p> <pre><code>https://www.onlinegdb.com/\n</code></pre> </li> <li> <p>Online Python</p> <p>Sauvegarde sur le PC</p> <pre><code>https://www.online-python.com/\n</code></pre> </li> </ul>"},{"location":"nsi/10_coder/#solution-2-installer-son-ide","title":"Solution 2 : Installer son IDE","text":"<ol> <li> <p>Installer Python  :</p> <pre><code>https://www.python.org/downloads/\n</code></pre> </li> <li> <p>Installer PyScripter (une version r\u00e9cente d'EduPython ) :</p> <pre><code>https://sourceforge.net/projects/pyscripter/\n</code></pre> </li> </ol>"},{"location":"nsi/20_s-entrainer/","title":"S'entra\u00eener","text":"<p>Voici quelques exercices pour t'entra\u00eener aux basiques de la programmation en Python.</p> <p>\u00a0\u00a0Tente de les r\u00e9soudre dans le temps imparti !</p>"},{"location":"nsi/20_s-entrainer/#et-si-je-galere","title":"Et si je gal\u00e8re ?","text":"<p>Des difficult\u00e9s \ud83d\ude23 ? </p> <p>Besoin de reprendre from scratch \ud83d\udcaa ?</p> <p>Une bonne ressource en ligne : https://www.france-ioi.org/algo/chapters.php</p> <p>N'h\u00e9site pas \u00e0 te cr\u00e9er un compte pour suivre tes progr\u00e8s.</p>"},{"location":"nsi/20_s-entrainer/#les-exercices","title":"Les exercices","text":"<p>\u00a0\u00a0Ouvrir un exercice lance le chrono !</p> <p>\ud83d\udca1 Tente de r\u00e9soudre le probl\u00e8me par toi-m\u00eame, et avant de r\u00e9v\u00e9ler la solution, v\u00e9rifie si tu as pens\u00e9 \u00e0 tout en d\u00e9roulant le \"Y as-tu pens\u00e9 ?\".</p> <p>\u26d4 Dans un but p\u00e9dagogique, il est bien s\u00fbr interdit d'utiliser les fonctions natives de Python qui r\u00e9aliserait le travail demand\u00e9.</p> Exercice 105:00 <p>Coder la fonction <code>volume_boule</code> permettant de calculer le volume d'une boule.</p> <p>Pour rappel :</p> \\[ V = \\frac{4}{3}\\times\\pi\\times r^{\u00b3} \\] Y as-tu pens\u00e9 ? <ul> <li> <p>Quels sont les param\u00e8tres de la fonction ?</p> </li> <li> <p>Si le rayon est nul ?</p> </li> <li> <p>Si le rayon est n\u00e9gatif ? (on n'est jamais \u00e0 l'abri d'une erreur de saisie \ud83e\udd2a)</p> </li> </ul> Solution <pre><code>from math import pi\n\ndef volume_boule(rayon : int) :\n    '''\n    Calcule le volume d'une boule de rayon \"rayon\"\n    '''\n\n    assert rayon &gt;= 0 , \"Le rayon doit \u00eatre positif !\"\n\n    return 4 / 3 * pi * rayon ** 3\n\n# Tests\nprint(volume_boule(1))          # 4.18879020\nprint(volume_boule(10.607845))  # 5000.00116\nprint(volume_boule(0))          # 0.0\nprint(volume_boule(-5))         # Erreur d'assertion\n</code></pre> Exercice 2.110:00 <p>Coder une fonction <code>multiplyArrayBy</code> permettant de multiplier toutes les valeurs d'une liste par un entier et qui renvoie les r\u00e9sultats dans une nouvelle liste.</p> <p>Autrement dit : </p> <pre><code>[1, 2, 3] x 2 \ud83e\udc72 [2, 4, 6]\n</code></pre> Y as-tu pens\u00e9 ? <ul> <li> <p>Si le tableau est vide ?</p> </li> <li> <p>Si les valeurs de la liste ne sont pas num\u00e9riques ?</p> </li> </ul> Solution <pre><code>def multiplyArrayBy(liste : list, entier : int) :\n    '''\n    Multiplie toutes les valeurs de liste par entier et renvoie les r\u00e9sultats dans une nouvelle liste.\n    '''\n    resultats = []\n\n    # On parcourt le tableau - premi\u00e8re version\n    for valeur in liste :\n\n        assert type(valeur) is int or type(valeur) is float, \"La liste doit contenir des valeurs num\u00e9riques !\"\n\n        resultats.append(valeur * entier)\n\n    # On parcourt le tableau - seconde version\n    # for i in range(len(liste)) :\n    #     assert type(liste[i]) is int or type(liste[i]) is float, \"La liste doit contenir des valeurs num\u00e9riques !\"\n    #     resultats.append(liste[i] * entier)\n\n    return resultats\n\n# Tests\nprint(multiplyArrayBy([1, 2, 3], 2))                # [2, 4, 6]\nprint(multiplyArrayBy([-3, 7.3, 10, 1, 0], 5))      # [-15, 36.5, 50, 5, 0]\nprint(multiplyArrayBy([], 42))                      # []\nprint(multiplyArrayBy(['a'], 42))                   # Erreur d'assertion\n</code></pre> Exercice 2.210:00 <p>Coder une fonction <code>multiplyArrayInPlaceBy</code> permettant de multiplier toutes les valeurs d'une liste par un entier mais qui, cette fois, remplace les valeurs dans la liste originale par les r\u00e9sultats.</p> Y as-tu pens\u00e9 ? <ul> <li> <p>Si le tableau est vide ?</p> </li> <li> <p>Si les valeurs de la liste ne sont pas num\u00e9riques ?</p> </li> </ul> Solution <pre><code>def multiplyArrayInPlaceBy(liste : list, entier : int) :\n    '''\n    Multiplie toutes les valeurs de liste par entier\n    '''\n\n    # On parcourt le tableau\n    # Pas le choix ici, l'acc\u00e8s par indice est la solution la plus \"propre\"\n    for i in range(len(liste)) :\n\n        assert type(liste[i]) is int or type(liste[i]) is float, \"La liste doit contenir des valeurs num\u00e9riques !\"\n\n        liste[i] *= entier\n        # liste[i] = liste[i] * entier\n\n    # On ne renvoie rien ici, les listes sont pass\u00e9es par r\u00e9f\u00e9rence en Python,\n    # les modifier dans la fonction les modifie dans la fonction appelante !\n\n# Tests\nl = [1, 2, 3]\nmultiplyArrayInPlaceBy(l, 2)\nprint(l)                                        # [2, 4, 6]\n\nl = [-3, 7.3, 10, 1, 0]\nmultiplyArrayInPlaceBy(l, 5)\nprint(l)                                        # [-15, 36.5, 50, 5, 0]\n\nl = []\nmultiplyArrayInPlaceBy(l, 42)\nprint(l)                                        # []\n\nl = ['a', 'b', 'c']\nmultiplyArrayInPlaceBy(l, 42)\nprint(l)                                        # Erreur d'assertion\n</code></pre> Exercice 315:00 <p>Coder la fonction <code>somme_prod</code> permettant de multiplier une \u00e0 une les valeurs de deux listes et d'en renvoyer la somme.</p> <p>Autrement dit : </p> <pre><code>[1, 2, 3] x [4, 5, 6] \ud83e\udc72 [4, 10, 18] \ud83e\udc72 32\n</code></pre> Y as-tu pens\u00e9 ? <ul> <li> <p>Si les tableaux sont vides ? </p> </li> <li> <p>Si les tableaux n'ont pas le m\u00eame nombre d'\u00e9l\u00e9ments ?</p> </li> <li> <p>Si les valeurs de la liste ne sont pas num\u00e9riques ?</p> </li> </ul> Solution <pre><code>def somme_prod(l1 : list, l2 : list) :\n    '''\n    Multiplie une \u00e0 une les valeurs des listes l1 et l2 et en renvoie la somme\n    '''\n\n    # On initialise \u00e0 0 une variable pour stocker la somme des produits au fur et \u00e0 mesure\n    somme = 0\n\n    assert len(l1) == len (l2), \"Les deux listes doivent avoir le m\u00eame nombre d'\u00e9l\u00e9ments !\"\n\n    for i in range(len(l1)) :\n\n        assert type(l1[i]) is int or type(l1[i]) is float, \"La liste 1 doit contenir des valeurs num\u00e9riques !\"\n        assert type(l2[i]) is int or type(l2[i]) is float, \"La liste 2 doit contenir des valeurs num\u00e9riques !\"\n\n        somme += l1[i] * l2[i]\n\n    return somme\n\n# Tests\nprint(somme_prod([1, 2, 3], [1, 2, 3]))         # 14\nprint(somme_prod([0.1, 2.3], [4.56, 78.9]))     # 181.926\nprint(somme_prod([], []))                       # 0\nprint(somme_prod([1, 2], []))                   # Erreur d'assertion\nprint(somme_prod([1, 2], [1, 'a']))             # Erreur d'assertion - Commenter la ligne pr\u00e9c\u00e9dente pour la voir\n</code></pre> Exercice 420:00 <p>Coder une fonction <code>saisirListe</code> qui demande \u00e0 l'utilisateur de saisir en une fois une liste d'entiers s\u00e9par\u00e9s par des espaces, puis la renvoie sous la forme d'un tableau d'entiers.</p> <p>Exemple</p> <pre><code>Saisir une liste d'entiers s\u00e9par\u00e9s par des espaces : 1 23 456 7 8 90\nR\u00e9sultat : [1, 23, 456, 7, 8, 90]\n</code></pre> Y as-tu pens\u00e9 ? <ul> <li> <p>Si l'utilisateur ne saisit rien ?</p> </li> <li> <p>As-tu convertit les entiers dans le bon type ?</p> </li> </ul> Solution <pre><code>def saisirListe() :\n    '''\n    Demande \u00e0 l'utilisateur de saisir une liste d'entiers s\u00e9par\u00e9s par des espaces, puis la renvoie sous la forme d'un tableau d'entiers.\n    '''\n    # On r\u00e9cup\u00e8re la saisie de l'utilisateur\n    saisie = input(\"Saisir une liste d'entiers s\u00e9par\u00e9s par des espaces : \")\n\n    # Une liste pour stocker le r\u00e9sultat\n    liste = []\n\n    # Une chaine temporaire pour stocker les caract\u00e8res lus\n    temporaire = \"\"\n\n    # On parcours la saisie caractere par caractere\n    for caractere in saisie :\n\n        # Si ce n'est pas un espace...\n        if caractere != ' ' :\n            # ...on concat\u00e8ne le caract\u00e8re dans une chaine temporaire\n            temporaire += caractere\n\n        # Si c'est un espace...\n        else :\n            # ...on convertit la chaine temporaire en entier et on le stocke dans la liste...\n            liste.append(int(temporaire))\n            # ...et on n'oublie pas de r\u00e9initialiser la chaine temporaire\n            temporaire = \"\"\n\n    # ET on n'oublie pas le dernier (qui n'est pas suivi d'un espace...) !\n    if len(temporaire) &gt; 0 :\n        liste.append(int(temporaire))\n\n    return liste\n\n# Test\nprint(\"R\u00e9sultat :\", saisirListe())\n\n# Saisir 1 2 3 4 5 donne : [1, 2, 3, 4, 5]\n# Saisir 12 345 donne : [12, 345]\n# Ne rien saisir donne : []\n# Saisir a b c renvoie une erreur de conversion : invalid literal for int() with base 10: 'a'\n</code></pre> Exercice 5.115:00 <p>Coder une fonction <code>calculer_distance_vol_oiseau</code> qui calcule la distance \\(d\\) \u00e0 vol d'oiseau entre deux points \\(A\\) et \\(B\\) du globe \u00e0 partir de leurs coordonn\u00e9es GPS en utilisant la formule de haversine.</p> <p>Voici la formule :</p> \\[\\begin{split} &amp;d=2r\\arcsin{(\\sqrt{\\sin^2{(\\frac{\\varphi_B - \\varphi_A}{2})}+\\cos{(\\varphi_A)}\\cos{(\\varphi_B)}\\sin^2{(\\frac{\\lambda_B - \\lambda_A}{2})}})} \\end{split}\\] <p>o\u00f9 :</p> <ul> <li> <p>\\(r\\) est le rayon de la terre : 6371 km,</p> </li> <li> <p>\\(\\varphi_A\\) et \\(\\varphi_B\\) sont les latitudes des points A et B,</p> </li> <li> <p>\\(\\lambda_A\\) et \\(\\lambda_B\\) sont les longitudes des points A et B,</p> </li> <li> <p>les latitudes et longitudes sont exprim\u00e9es en radians (\\(1 \u00b0 \u00d7 \u03c0/180 = 0,01745 rad\\)),</p> </li> <li> <p>les fonctions trigonom\u00e9triques sont disponibles dans la biblioth\u00e8que <code>math</code>.</p> </li> </ul> <p>R\u00e9sultats attendus :</p> A B Distance Petit bois \u00e0 l'ImmacLatitude : <code>48.07465140238585</code>Longitude : <code>-0.7685811118128099</code> Kiosque du Square de BostonLatitude : <code>48.07352246874617</code>Longitude : <code>-0.7723670509520487</code> 308 m Tour EiffelLatitude : <code>48.8584830111056</code>Longitude : <code>2.2944598391027196</code> Golden GateLatitude : <code>37.82000588671323</code>Longitude : <code>-122.47860249700975</code> 8949 km Solution <pre><code>from math import cos, pi, sqrt, sin, asin\n\ndef calculer_distance_vol_oiseau(latA : float, lngA : float, latB : float, lngB : float) :\n    '''\n    Calcule la distance \u00e0 vol d'oiseau entre deux points A(latA, lngA) et B(latB, lngB) du globe \u00e0 partir de leurs coordonn\u00e9es GPS.\n    '''\n\n    distance = 0\n\n    # Conversion en radians\n    latA = latA * pi / 180\n    lngA = lngA * pi / 180\n    latB = latB * pi / 180\n    lngB = lngB * pi / 180\n\n    # Calcul de la distance\n    distance =  2 * 6371 * asin(sqrt(sin((latB - latA) / 2) ** 2 + cos(latA) * cos(latB) * sin((lngB - lngA) / 2) ** 2))\n\n    return distance\n\n# Tests\n\nprint(calculer_distance_vol_oiseau(48.07465140238585, -0.7685811118128099, 48.07352246874617, -0.7723670509520487)) #  308 m\n\nprint(calculer_distance_vol_oiseau(48.8584830111056, 2.2944598391027196, 37.82000588671323, -122.47860249700975))   # 8949 km\n</code></pre> Exercice 5.215:00 <p>Reprendre la fonction cr\u00e9\u00e9e \u00e0 l'exercice 5.1 en l'adaptant pour qu'elle prenne en entr\u00e9e un dictionnaire au format suivant :</p> <pre><code>trajet = {\n    \"A\" : {\n        \"nom\" : \"Petit bois \u00e0 l'Immac\",\n        \"lat\" : 48.07465140238585,\n        \"lng\" : -0.7685811118128099\n    },\n    \"B\" : {\n        \"nom\" : \"Kiosque du Square de Boston\",\n        \"lat\" : 48.07352246874617,\n        \"lng\" : -0.7723670509520487\n    },\n    \"distance\" : 0\n}\n</code></pre> <p>La distance calcul\u00e9e par la fonction doit \u00eatre stock\u00e9e comme valeur de la cl\u00e9 <code>distance</code>.</p> Solution <pre><code>from math import cos, pi, sqrt, sin, asin\n\ndef calculer_distance_vol_oiseau(trajet : dict) :\n    '''\n    Calcule la distance \u00e0 vol d'oiseau entre deux points A(latA, lngA) et B(latB, lngB) du globe \u00e0 partir de leurs coordonn\u00e9es GPS.\n    '''\n\n    distance = 0\n\n    # Conversion en radians (on garde des variables locales pour ne pas modifier le dictionnaire)\n    latA = trajet[\"A\"][\"lat\"] * pi / 180\n    lngA = trajet[\"A\"][\"lng\"] * pi / 180\n    latB = trajet[\"B\"][\"lat\"] * pi / 180\n    lngB = trajet[\"B\"][\"lng\"] * pi / 180\n\n    # Calcul de la distance\n    trajet[\"distance\"] =  2 * 6371 * asin(sqrt(sin((latB - latA) / 2) ** 2 + cos(latA) * cos(latB) * sin((lngB - lngA) / 2) ** 2))\n\n    # Rien \u00e0 renvoyer : les dictionnaires comme les listes sont pass\u00e9s par r\u00e9f\u00e9rences\n    # (modifier le dictionnaire dans la fonction le modifie dans la fonction appelante)\n\n# Tests\n\ntrajet1 = {\n    \"A\" : {\n        \"nom\" : \"Petit bois \u00e0 l'Immac\",\n        \"lat\" : 48.07465140238585,\n        \"lng\" : -0.7685811118128099\n    },\n    \"B\" : {\n        \"nom\" : \"Kiosque du Square de Boston\",\n        \"lat\" : 48.07352246874617,\n        \"lng\" : -0.7723670509520487\n    },\n    \"distance\" : 0\n}\ncalculer_distance_vol_oiseau(trajet1)\nprint(trajet1[\"distance\"])              #  308 m\n\n#print(calculer_distance_vol_oiseau(48.8584830111056, 2.2944598391027196, 37.82000588671323, -122.47860249700975))\ntrajet2 = {\n    \"A\" : {\n        \"nom\" : \"Tour Eiffel\",\n        \"lat\" : 48.8584830111056,\n        \"lng\" : 2.2944598391027196\n    },\n    \"B\" : {\n        \"nom\" : \"Golden Gate\",\n        \"lat\" : 37.82000588671323,\n        \"lng\" : -122.47860249700975\n    },\n    \"distance\" : 0\n}\ncalculer_distance_vol_oiseau(trajet2)\nprint(trajet2[\"distance\"]) # 8949 km\n</code></pre> Exercice 6.13:00 <p>Expliquer pourquoi le programme suivant renvoie une erreur <code>SyntaxError</code> :</p> <pre><code>def surpuissance_seconde(x)\n    return x ** x\n\nsurpuissance_seconde(2)\n</code></pre> Solution <p>Il manque le deux-points (<code>:</code>) qui termine l'en-t\u00eate de la fonction :</p> <pre><code>                            \ud83e\udc73\ndef surpuissance_seconde(x) :\n    return x ** x\n\nsurpuissance_seconde(2)\n</code></pre> Exercice 6.23:00 <p>Expliquer pourquoi le programme suivant renvoie une erreur <code>IndentationError</code> :</p> <pre><code>def valeurAbsolue(x) :\nreturn sqrt(x ** 2)\n\nvaleurAbsolue(-42)\n</code></pre> Solution <p>Il faut indenter le corps de la fonction :</p> <pre><code>def valeurAbsolue(x) :\n\ud83e\udc72\ud83e\udc72\ud83e\udc72\ud83e\udc72return sqrt(x ** 2)\n\nvaleurAbsolue(-42)\n</code></pre> Exercice 6.33:00 <p>Expliquer pourquoi le programme suivant renvoie une erreur <code>NameError</code> :</p> <pre><code>def incremente(x) :\n    resultat = x + 1\n    return resultat\n\nprint(resultat)\n</code></pre> Solution <p><code>resultat</code> est une variable locale de la fonction <code>incremente</code>.</p> <p>On ne peut pas l'utiliser \u00e0 l'ext\u00e9rieur de la fonction.</p> <p>Ici, il faut utiliser le retour de la fonction pour r\u00e9cup\u00e9rer la valeur de <code>resultat</code> :</p> <pre><code>def incremente(x) :\n    resultat = x + 1\n    return resultat\n\nprint(incremente(41))\n</code></pre> Exercice 6.43:00 <p>Expliquer pourquoi le programme suivant affiche <code>None</code> en ex\u00e9cutant la ligne 5 :</p> <pre><code>def decremente(x) :\n    print(x - 1)\n\nresultat = decremente(43)\nprint(resultat)\n</code></pre> Solution <p><code>print</code> n'\u00e9quivaut pas \u00e0 un <code>return</code>. Elle ne fait qu'afficher la valeur \u00e0 l'\u00e9cran.</p> <p>La fonction <code>decremente</code> ne renvoie donc rien (<code>None</code> en Python).</p> <pre><code>def decremente(x) :\n    return x - 1\n\nresultat = decremente(43)\nprint(resultat)\n</code></pre> Exercice 6.55:00 <p>Expliquer pourquoi le programme suivant n'affiche que <code>h</code> :</p> <pre><code>def remplacerEspacePar(texte : str, car : str) :\n    resultat = \"\"\n    for i in range(len(texte)) :\n        if texte[i] == \" \" :\n            resultat += car\n        else :\n            resultat += texte[i]\n        return resultat\n\nprint(remplacerEspacePar(\"hello, world! how are you ?\", \"*\"))\n</code></pre> Solution <p>Si on regarde l'indentation, le <code>return</code> ligne 8 est dans la boucle <code>for</code>, ce qui a pour effet d'arr\u00eater le programme d\u00e8s la premi\u00e8re ex\u00e9cution de la boucle.</p> <p>Il faut \"reculer\" l'instruction ligne 8 au niveau du <code>for</code> pour que la boucle s'ex\u00e9cute compl\u00e8tement.</p> <pre><code>def remplacerEspacePar(texte : str, car : str) :\n    resultat = \"\"\n    for i in range(len(texte)) :\n        if texte[i] == \" \" :\n            resultat += car\n        else :\n            resultat += texte[i]\n    return resultat\ud83e\udc70\ud83e\udc70\ud83e\udc70\ud83e\udc70\n\nprint(remplacerEspacePar(\"hello, world! how are you ?\", \"*\"))\n</code></pre> Exercice 6.65:00 <p>Expliquer pourquoi le programme suivant renvoie une erreur <code>TypeError</code> :</p> <pre><code>def ajoute_entier_a_chaque_valeur(valeurs : list, entier : int) :\n    for i in range(len(valeurs)) :\n        valeurs[i] += entier\n\nun_deux_trois = [1, 2, 3]\najoute_entier_a_chaque_valeur(5, un_deux_trois)\nprint(un_deux_trois)\n</code></pre> Solution <p>Il faut respecter l'ordre des param\u00e8tres (arguments d'entr\u00e9e) de la fonction.</p> <p>La fonction <code>ajoute_entier_a_chaque_valeur</code> attend une liste puis un entier.</p> <p>A la ligne 6, on lui fournit un entier puis une liste ce qui cause l'erreur.</p> <p>Il suffit d'inverser les param\u00e8tres \u00e0 la ligne 6 pour que le programme fonctionne.</p> <pre><code>                                     \ud83e\udc73              \ud83e\udc73\ndef ajoute_entier_a_chaque_valeur(valeurs : list, entier : int) :\n    for i in range(len(valeurs)) :\n        valeurs[i] += entier\n\nun_deux_trois = [1, 2, 3]          \ud83e\udc73        \ud83e\udc73\najoute_entier_a_chaque_valeur(un_deux_trois, 5)\nprint(un_deux_trois)\n</code></pre>"}]}