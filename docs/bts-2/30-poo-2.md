# 03 - POO level 2

## Exercice 1

Sur la base du diagramme de classes ci-dessous, créer le programme qui permet de saisir les noms de plusieurs personnes puis un nombre de groupes à créer. 

![group_person.png](../images/cours/bts-2/30/group_person.png)

Le programme se chargera ensuite de répartir automatiquement les personnes dans les groupes. 

Finalement il affichera la composition des groupes et le groupe d'appartenance de chaque personne.
    
??? tip "Indice"
    
    La classe `std::vector` peut être utile.
    
??? tip "Indice"
    
    On créera d'abord les personnes, puis les groupes dans le `main`.

    Ensuite on attache les personnes aux groupes et les groupes aux personnes.

    On manipulera des **pointeurs** pour les références afin d'éviter les recopies d'objets.

```
> ./exo_1.exe
Saisir les noms des personnes à créer (! pour arrêter) :
#1 : Bianca
#2 : Tryphon
#3 : Archibald
#4 : Allan
#5 : Piotr
#6 : Tchang
#7 : Seraphin
#8 : !
7 personnes saisies.

Nombre de groupes à créer : 3

1
Bianca (1)
Allan (4)
Seraphin (7)

2
Tryphon (2)
Piotr (5)

3
Archibald (3)
Tchang (6)

Bianca (1) appartient au groupe 1
Tryphon (2) appartient au groupe 2
Archibald (3) appartient au groupe 3
Allan (4) appartient au groupe 1
Piotr (5) appartient au groupe 2
Tchang (6) appartient au groupe 3
Seraphin (7) appartient au groupe 1
```

??? success "Correction"

    :octicons-file-24: exo1/person.hpp

    ```cpp
    #include <string>

    #ifndef PERSON_H
    #define PERSON_H

    using namespace std;

    class Group;   // On triche pour éviter une mise en abyme infinie des includes croisés.

    class Person {
        private :
            int id;
            static int count;
            string name;
            Group * group;  // Pour éviter les recopies d'objets, on utilise un pointeur.

        public:
            Person(string);
            void display();
            Group * getGroup();
            void setGroup(Group &); // Le passage par référence simplifie l'utilisation de la méthode.
    };

    #endif
    ```

    :octicons-file-24: exo1/person.cpp

    ```cpp
    #include "person.hpp"
    #include "group.hpp"
    #include <iostream>
    #include <string>

    using namespace std;

    int Person::count = 0;

    Person::Person(string _name) {
        name = _name;
        count++;
        id = count;
    }

    void Person::display() {
        cout << name << " (" << id << ")";
    }

    void Person::setGroup(Group & _group) {
        group = & _group;
    }

    Group * Person::getGroup() {
        return group;
    }
    ```

    :octicons-file-24: exo1/group.hpp

    ```cpp
    #include <vector>

    #ifndef GROUP_H
    #define GROUP_H

    using namespace std;

    class Person;   // On triche pour éviter une mise en abyme infinie des includes croisés.

    class Group {
        private :
            int id;
            vector<Person *> people;  // Pour éviter les recopies d'objets, on utilise des pointeurs.
            static int count;

        public :
            Group();
            int getId();
            void addPerson(Person &); // Le passage par référence simplifie l'utilisation de la méthode.
            void display();
    };

    #endif
    ```

    :octicons-file-24: exo1/group.cpp

    ```cpp
    #include "group.hpp"
    #include "person.hpp"
    #include <iostream>

    using namespace std;

    int Group::count = 0;

    Group::Group() {
        count++;
        id = count;
    }

    int Group::getId() {
        return id;
    }

    void Group::addPerson(Person & p) {
        people.push_back(&p);
    }

    void Group::display() {
        cout << id << endl;
        for (int i = 0; i < people.size(); i++) {
            people[i]->display();   // -> car ce sont des pointeurs qu'on manipule
            cout << endl;
        }
    }
    ```

    :octicons-file-24: exo1/main.cpp

    ```cpp
    #include <iostream>
    #include <vector>
    #include <string>
    #include "person.hpp"
    #include "group.hpp"

    using namespace std;

    int main() {

        vector<Person> allPeople;   // Un tableau pour stocker les personnes créées au fur et à mesure.
        vector<Group> allGroups;    // Un tableau pour stocker les groupes créés.
        
        string input = "";          // Un tampon pour récupérer les noms saisis.
        int nbGroups = 0;
        
        system("chcp 65001");       // Passage de la console Windows en UTF-8
        system("cls");              // Nettoyage de la console

        // Saisie
        cout << "Saisir les noms des personnes à créer (vide pour arrêter) :" << endl;
        do {
            cout << "#" << allPeople.size() + 1 << " : ";
            
            getline(cin, input);    // Permet d'autoriser les saisies vides.

            // Création d'une nouvelle personne
            if (input != "") {
                allPeople.push_back(Person(input));
            }

        } while (input != "");

        cout << endl << allPeople.size() << " personne(s) saisie(s)" << endl << endl;

        // Création des groupes
        do {
            cout << "Nombre de groupes à créer : ";
            cin >> nbGroups;
        } while (nbGroups <= 0);
        for (int i = 0; i < nbGroups; i++) {
            allGroups.push_back(Group());
        }

        // Répartition des personnes dans les groupes
        for (int i = 0; i < allPeople.size(); i++) {
            allGroups[i % nbGroups].addPerson(allPeople[i]);
            allPeople[i].setGroup(allGroups[i % nbGroups]);
        }

        // Affichage des groupes
        cout << endl;
        for (int i = 0; i < allGroups.size(); i++) {
            allGroups[i].display();
            cout << endl;
        }
        cout << endl;

        // Affichage des personnes
        for (int i = 0; i < allPeople.size(); i++) {
            allPeople[i].display();
            cout << " appartient au groupe " << allPeople[i].getGroup()->getId() << endl;
        }

        return 0;
    }
    ```

## Exercice 2

![Diagramme de classe Bibliothèque](../images/cours/bts-2/30/bibliotheque.png)

Répondre aux questions suivantes portant sur le diagramme de classes, fruit du travail de conception d’un programme de gestion d’une bibliothèque.

1.	Peut-on créer des utilisateurs sans spécifier de nom&nbsp;? Expliquer.

    ??? success "Correction"


2.	Expliquer à quoi correspondent chacun des termes et symboles de la ligne suivante : `isEmailValid(string) : bool`

    ??? success "Correction"



3.	Pourquoi la ligne `+ setEmail(string)` de la classe `Utilisateur` n'a pas de partie avec les `:`&nbsp;?

    ??? success "Correction"



4.	Peut-on valider le format d’un email avec la méthode `isEmailValid` en l’appelant sur un objet `Utilisateur` créé dans le programme principal&nbsp;? Expliquer.

    ??? success "Correction"



5.	Peut-on modifier un emprunt après création&nbsp;? Expliquer.

    ??? success "Correction"



6.	Doit-on créer un objet `Emprunt` par exemplaire emprunté ou un objet `Emprunt` peut-il concerné plusieurs exemplaires d’un coup&nbsp;? Expliquer.

    ??? success "Correction"



7.	Les attributs `dateEmprunt` et `dateRetourPrevu` de la classe `Emprunt` n’ont pas de mutateur et le constructeur n’a pas de paramètre de type date. Qu’en déduisez-vous sur la valorisation de ces deux dates&nbsp;?

    ??? success "Correction"



8.	De quel type est l’attribut `emprunts` de la classe `Utilisateur`. Proposer deux manières différentes de l’implémenter en C++. 

    ??? success "Correction"



9.	L’attribut `- nombre : int` de la classe `Exemplaire` est souligné, qu’est-ce que cela signifie&nbsp;?

    ??? success "Correction"



10.	Il n’y a pas de mutateur prévu pour l’attribut `- nombre : int` de la classe `Exemplaire`, comment peut-on incrémenter ou décrémenter cet attribut&nbsp;?

    ??? success "Correction"



11.	Comment peut-on, à tout moment, connaître le nombre total de documents disponibles dans la bibliothèque&nbsp;?

    ??? success "Correction"



12.	Pourrait-on mettre en place sur la classe `Emprunt` un attribut `- nombre : int` avec la même caractéristique qu’à la question 9 pour compter le nombre d’emprunts d’un utilisateur&nbsp;? 

    Si oui, que doit-on mettre en place&nbsp;? 
    
    Si non, expliquer pourquoi et indiquer comment réaliser cette demande.

    ??? success "Correction"



13.	En utilisant les méthodes disponibles, peut-on à partir d’un objet `Livre` remonter jusqu’aux utilisateurs qui en ont emprunté un exemplaire&nbsp;? Expliquer. 

    ??? success "Correction"



14.	Peut-on avoir des emplacements vides&nbsp;? Pourquoi&nbsp;?

    ??? success "Correction"



15.	Compléter la déclaration en C++ de la classe Emplacement. 

    On supposera que les directives #include nécessaires ont été réalisées au préalable. 
    
    Ne pas définir les méthodes. 
    
    Les tableaux d’objets `Type` sont déclarés sous la forme d’un objet `vector<Type>`.
    
    ```cpp
    class Emplacement {
    
    };
    ```

    ??? success "Correction"



16.	Définir en C++ à l’extérieur de la déclaration de la classe `Livre` les méthodes accesseur et mutateur de l’attribut `titre`.

    ??? success "Correction"

