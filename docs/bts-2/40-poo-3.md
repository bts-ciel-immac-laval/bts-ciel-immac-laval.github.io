# 04 - POO ++

## Constructeur par recopie

![Constructeur par recopie](../pdf/cours/bts2/bts2_03_constructeur_recopie.pdf)

### Exercice 0

Compl√©ter la classe `Tab` suivante permettant de g√©rer un tableau d‚Äôentiers en allocation dynamique et pr√©sentant un bug lors de son utilisation  dans le fichier exo.cpp √† la ligne 17.
    
```cpp
// Tab.h
#ifndef TAB_H
#define TAB_H
class Tab {
    private :
        int count;
        int * first;
    public :
        Tab(int);
        ~Tab();
        void insert(int, int);
        int get(int);
        void display();
};
#endif
```

```cpp
// Tab.cpp
#include "Tab.h"
#include <iostream>

Tab::Tab(int _count) {
    count = _count;
    first = new int[count]{0};
}

Tab::~Tab() {
    delete [] first;
}

void Tab::insert(int i, int value) {
    if (i >= 0 && i < count) {
        first[i] = value;
    }
}

int Tab::get(int i) {
    if (i >= 0 && i < count) {
        return first[i];
    }
    throw "Indice hors-limite !";
}

void Tab::display(){
    std::cout << "[ ";
    for (int i = 0; i < count; i++) {
        std::cout << first[i] << (i < count - 1 ? ", " : "" );
    }
    std::cout << " ]\n";
}
```

```cpp  linenums="1"
// exo0.cpp
#include "Tab.h"

int main() {
    Tab t1(10);

    t1.display();
    t1.insert(3, 45);
    t1.insert(7, -89053);
    t1.display();
    std::cout << "t1[3] : " << t1.get(3) << std::endl;

    Tab t2 = t1;
    t2.display();
    t2.insert(6, 78);
    t2.display();
    t1.display(); // üò±

    return 0;
}
```

??? success "Solution"
    
    ```cpp
    // Tab.h
    #ifndef TAB_H
    #define TAB_H
    class Tab {
        private :
            int count;
            int * first;
        public :
            Tab(int);
            Tab(Tab &); // <- D√©claration du constructeur par recopie
            ~Tab();
            void insert(int, int);
            int get(int);
            void display();
    };
    #endif
    ```

    Ajouter dans 'Tab.cpp' :
    
    ```cpp
    // D√©finition du constructeur par recopie
    Tab::Tab(Tab & t) {
        count = t.count;
        first = new int[count]{0};
        for (int i = 0; i < count; i++) {
            first[i] = t.first[i];
        }
    }
    ```

### Exercice 1

Soit le programme suivant :

```cpp
#include "Truc.h"

void fonction (Truc a) {
	// Ne se passe-t-il vraiment rien ici ü§î
}

int main() {
    Truc x;
    Truc y = x;
    fonction(y);
    cout << "Bonjour !" << endl;
}
```

Cr√©er la classe `Truc` de mani√®re √† ce que le programme ci-dessus fournisse le r√©sultat suivant :

```
> ./exo1.exe
Cr√©ation d'un truc
Copie d'un truc
Copie d'un truc
Destruction d'un truc
Bonjour !
Destruction d'un truc
Destruction d'un truc
```

??? success "Solution"
    
    ```cpp
    #include <iostream>

    using namespace std;

    class Truc {
        public:
            Truc() {
                cout << "Cr√©ation d'un truc" << endl;
            }
            Truc(Truc & t) {
                cout << "Copie d'un truc" << endl;
            }
            ~Truc() {
                cout << "Destruction d'un truc" << endl;
            }
    };
    ```

    On passe deux fois dans le constructeur par recopie :

    +   √† l'initialisation de y avec x

    +   lors de la recopie de y dans a quand on appelle fonction(y)

### Exercice 2

!!! danger "A faire sur papier !"

Que va afficher le programme suivant ?

```cpp
#include <iostream>

using namespace std;

class Point {
    private:
        int x, y;
    public:
        Point(int abs = 1, int ord = 0) {
            x = abs;
            y = ord;
            cout << "C : " << x << ", " << y << endl;
        };
        Point(Point &);
        ~Point();
};

Point::Point(Point & d) {
    cout << "R : " << d.x << ", " << d.y << endl;
    x = d.x;
    y = d.y;
}

Point::~Point() {
    cout << "D !"<< endl;
}

void fct (Point, Point *);

int main() {
    cout << "D√©but main" << endl;
    Point a;
    Point c = a;
    Point *adr = new Point (3, 3);
    fct(a, adr);
    c = Point(5, 5);
    cout << "Fin main" << endl;
}

void fct (Point d, Point * add) {
    cout << "Entr√©e fct" << endl;
    delete add;
    cout << "Sortie fct" << endl;
}
```

??? success "Solution"

    ```cpp
    D√©but main
    C : 1, 0    // (1)!
    R : 1, 0    // (2)!
    C : 3, 3    // (3)!
    R : 1, 0    // (4)!
    Entr√©e fct
    D !         // (5)!
    Sortie fct
    D !         // (6)!
    C : 5, 5    // (7)!
    D !         // (8)!
    Fin main
    D !         // (9)!
    D !         // (10)!
    ```

    1.  Cr√©ation de a
    2.  Recopie de a dans c
    3.  Cr√©ation du point dans le tas
    4.  Recopie de a dans le param√®tre d (passage par valeur)
    5.  Destruction du point cr√©√© dans le tas
    6.  Destruction de d
    7.  Cr√©ation du point √©ph√©m√®re avant affectation dans c
    8.  Destruction du point √©ph√©m√®re
    9.  Destruction de c
    10. Destruction de a

## Surd√©finition d'op√©rateur

![Surd√©finition d'op√©rateur](../pdf/cours/bts2/bts2_04_surdefinition_operateurs.pdf)

### Exercice 3

Soit une classe Vecteur3d :

```cpp
class Vecteur3d {
    private:
        float x, y, z;
    public:
        Vecteur3d (int _x = 0, int _y = 0, int _z = 0) {
            x = _x;
            y = _y;
            z = _z;
        }
};
```

1.  Surd√©finir l'op√©rateur == en utilisant une fonction membre inline.
    
    Deux `Vecteur3D` sont √©gaux si leurs coordonn√©es sont respectivement √©gales.
    
2.  Surd√©finir l'op√©rateur != en utilisant une fonction membre inline.
    
    !!! danger "Trouver un moyen "malin" ne pas utiliser les attributs x, y, z pour la surcharge de l'op√©rateur !=."

3.  Cr√©er un programme de test.

??? success "Solution"

    ```cpp
    #include <iostream>

    using namespace std;

    class Vecteur3d {
        private:
            float x, y, z;
        public:
            Vecteur3d (int _x = 0, int _y = 0, int _z = 0) {
                x = _x;
                y = _y;
                z = _z;
            }
            bool operator == (Vecteur3d &);
            bool operator != (Vecteur3d &);
    };

    // Les fonctions inline doivent √™tre dans le m√™me fichier que la d√©claration de la classe

    inline bool Vecteur3d::operator == (Vecteur3d & v) {
        return (x == v.x && y == v.y && z == v.z);
    }

    inline bool Vecteur3d::operator != (Vecteur3d & v) {
        return (!(*this == v));
    }

    int main() {

        Vecteur3d a, b, c(1, 2, 3);

        if (a == b) {
            cout << "a == b" << endl;
        }
        
        if (a == c) {
            cout << "On ne doit pas passer ici !" << endl;
        }

        if (a != b) {
            cout << "Ni l√† !" << endl;
        }

        if (a != c) {
            cout << "a != c" << endl;
        }


        return 0;
    }
    ```

### Exercice 4

Reprendre la classe `Tab` de l‚Äôexercice 0.

1.  Surd√©finir l'op√©rateur `=` pour que **l'affectation** soit possible entre deux objets `Tab`.
    
    ```cpp
    Tab t1(10), t2(5);
    t2 = t1;
    ```
    
2.  Surd√©finir l'op√©rateur `[ ]` pour affecter et r√©cup√©rer des valeurs directement dans le tableau sans passer par `set` ou `get`. 
Ne pas oublier d'indiquer un d√©bordement d'indice du tableau. 
Dans ce cas, on lancera une exception.
    
    ```cpp
    Tab t1(10);
    t1[5] = 7;
    cout << t1[3];
    ```
    
    ??? tip "Un peu d‚Äôaide ?"
        
        [https://en.cppreference.com/w/cpp/language/operators#Array_subscript_operator](https://en.cppreference.com/w/cpp/language/operators#Array_subscript_operator)
        
3.  Surd√©finir l‚Äôop√©rateur `+` pour concat√©ner des tableaux.

4.  Trouver un moyen d‚Äôafficher un tableau au complet √† l‚Äôaide de `cout`.
    
    ```cpp
    Tableau t1(10);
    t1[5] = 7;
    cout << t1;
    ```

??? success "Solution"

    ```cpp
    // Tab.h
    #include <iostream>

    using namespace std;

    #ifndef TAB_H
    #define TAB_H
    class Tab {
        private :
            int count;
            int * first;
        public :
            Tab(int);
            Tab(Tab &);
            ~Tab();
            Tab & operator = (Tab);
            int & operator [] (int);
            Tab operator + (Tab &);
            // Fonction "amie" d√©finie √† l'ext√©rieur de la classe ostream, 
            // mais qui aura acc√®s √† tous les attributs de la classe.
            friend ostream & operator << (ostream &, Tab &);
    };
    #endif
    ```

    ```cpp
    // Tab.cpp
    #include "Tab.h"
    
    Tab::Tab(int _count) {
        count = _count;
        first = new int[count]{0};
    }

    Tab::Tab(Tab & t) {
        count = t.count;
        first = new int[count]{0};
        for (int i = 0; i < count; i++) {
            first[i] = t.first[i];
        }
    }

    Tab::~Tab() {
        delete [] first;
    }

    Tab & Tab::operator = (Tab t) {
        count = t.count;
        // On n'oublie pas d'effacer l'ancien tableau
        delete [] first;
        first = new int[count]{0};
        for (int i = 0; i < count; i++) {
            first[i] = t.first[i];
        }
        return *this;
    }

    int & Tab::operator [] (int i) {
        if (i > count) {
            throw "Indice hors-limite !"; // On lance une exception pour interrompre le programme.
        }
        return first[i];
    }

    Tab Tab::operator + (Tab & t) {
        // Nouveau tableau 
        Tab tNew(count + t.count);
        // Remplissage de la premi√®re partie avec les valeurs de l'objet courant
        for (int i = 0; i < count; i++) {
            tNew.first[i] = first[i];
        }
        // Remplissage de la deuxi√®me partie avec les valeurs de l'objet en param√®tre
        for (int i = 0; i < t.count; i++) {
            tNew.first[i + count] = t.first[i];
        }
        // On renvoie le nouveau tableau
        return tNew;
    }

    // Fonction amie donc juste operator et non Tab::operator
    ostream & operator << (ostream & os, Tab & t) {
        os << "[ ";
        for (int i = 0; i < t.count; i++) {
            std::cout << t.first[i] << (i < t.count - 1 ? ", " : "" );
        }
        os << " ]\n";
        return os;
    }
    ```

    ```cpp
    // exo4.cpp
    #include "Tab.h"

    int main() {
        Tab t1(10), t2(5), t3(1);
        
        cout << t2;             // Surd√©finition de l'op√©rateur << de ostream
        t2 = t1;                // Surd√©finition de l'op√©rateur =
        cout << t2;             // Surd√©finition de l'op√©rateur << de ostream

        cout << t1;             // Surd√©finition de l'op√©rateur << de ostream
        t1[5] = 7;              // Surd√©finition de l'op√©rateur [ ]
        cout << t1[5] << endl;  // Surd√©finition de l'op√©rateur [ ]
        cout << t1;             // Surd√©finition de l'op√©rateur << de ostream

        cout << t3;             // Surd√©finition de l'op√©rateur << de ostream
        t2[3] = 42;             // Surd√©finition de l'op√©rateur [ ]
        t3 = t1 + t2;           // Surd√©finition de l'op√©rateur + et =
        cout << t3;             // Surd√©finition de l'op√©rateur << de ostream

        return 0;
    }
    ```

